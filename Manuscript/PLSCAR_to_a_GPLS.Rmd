---
title: "A generalization of partial least squares regression and correspondence analysis for categorical and mixed data: An application with the ADNI data"

# to produce blinded version set to 1
blinded: 0

authors: 
- name: Derek Beaton
  # thanks: Acknowledgements?
  affiliation: Rotman Research Institute, Baycrest Health Sciences

- name: ADNI
  affiliation: ADNI
  thanks: Data used in preparation of this article were obtained from the Alzheimer's Disease Neuroimaging Initiative (ADNI) database (http://adni.loni.usc.edu/). As such, the investigators within the ADNI contributed to the design and implementation of ADNI and/or provided data but did not  participate in  analysis  or  writing  of  this  report. A  complete  listing  of  ADNI  investigators can be found at http\://adni.loni.ucla.edu/wpcontent/uploads/how\_to\_apply/ADNI\_Acknowledgement\_List.pdf
  
- name: Gilbert Saporta
  affiliation: Conservatoire National des Arts et Metiers
  
- name: Herv√© Abdi
  affiliation: Behavioral and Brain Sciences, The University of Texas at Dallas
  
keywords:
- generalized singular value decomposition
- latent models
- genetics
- neuroimaging
- canonical correlation analysis

abstract: |
  Current large scale studies of brain
  and behavior typically involve multiple populations, 
  diverse types of data (e.g., 
  genetics, brain structure, 
  behavior, demographics, or "mutli-omics," and "deep-phenotyping")
  measured
   on 
  various scales of measurement. 
  To analyze  these heterogeneous data sets we need 
  simple but flexible methods able to integrate
  the inherent properties of these complex data sets. 
  Here we introduce partial least squares-correspondence 
  analysis-regression (PLS-CA-R) a method 
  designed to address these constraints.
  PLS-CA-R generalizes PLS regression 
  to 
    most data types (e.g., continuous, 
  ordinal, categorical, non-negative values). 
  We also show that PLS-CA-R 
    generalizes many "two-table" 
  multivariate techniques and their respective algorithms, 
  such as various PLS approaches, canonical correlation analysis, 
  and redundancy analysis (a.k.a. reduced rank regression).
   
bibliography: plscar.bib
output: rticles::asa_article
header-includes: 
  - \usepackage{float}
  - \usepackage{bbold}
  - \usepackage{subfig}
  - \usepackage{graphicx}
  - \usepackage[utf8]{inputenc}
  - \usepackage[T1]{fontenc}
  - \usepackage{booktabs}
  - \usepackage{algorithm2e}
  - \usepackage{caption}
  - \usepackage{tabularx}
  - \usepackage{verbatim}
  - \usepackage{xcolor}
  - \newcommand{\var}{\mathrm{Var}}
---

```{r paper_setup, echo=F, include=F}
library(knitr)
library(kableExtra)
## need pandoc latex tables but skip this for now...?
```
```{r example_setup, echo=F, include=F}
library(TExPosition)
library(GSVD)
library(GPLS)
library(corrplot)
library(plotrix)
library(dplyr)
library(here)

load(paste0(Sys.getenv("DATA_DIR"),"TADPOLE.fin2.rda"))
load(paste0(Sys.getenv("DATA_DIR"),"genetic.data.rda"))
load(paste0(Sys.getenv("DATA_DIR"),"TADPOLE_Dict.fin2.rda"))


source("../Code/supplemental_functions.R")
source("../Code/data_prep_after_load.R")
  
```

# Introduction
\label{section:Intro}

Today's large scale and multi-site studies, such as the UK BioBank
(https://www.ukbiobank.ac.uk/) 
and the Rotterdam study (http://www.erasmus-epidemiology.nl/), 
collect population level data across numerous types and modalities, 
(e.g., genetics, neurological, behavioral, clinical, and laboratory measures). 
Other types of large scale studies---typically 
those that emphasize diseases and disorders---involve 
a relatively small of participants but
collect a very large number of measures on diverse modalities. 
Some such studies include the Ontario Neurodegenerative Disease Research 
Initiative (ONDRI) [@farhan_ontario_2016] which includes genetics,
multiple types of magnetic resonance brain imaging 
[@duchesne_canadian_2019], a wide array of behavioral, 
cognitive, clinical, and laboratory batteries, 
as well as many modalities "between" these types, 
such as ocular imaging, gait, and balance [@montero-odasso_motor_2017-1], 
eye tracking, and neuro-pathology. 
Though large samples (e.g., UK BioBank) 
and depth of data (e.g., ONDRI) are necessary 
to understand typical and disordered samples and populations, 
few statistical or machine learning approaches exist 
1) that can accommodate such large 
(whether "big" or "wide"), complex, and heterogeneous data sets 
and 2) that also respect the inherent properties of such data.


In many cases, the analysis of a mixture of data types
loses
information  in part because the data need to be
transformed to fit the analytical methods; but this analysis
also loses inferential power
because the standard assumptions may be inappropriate or incorrect.
For example, to analyze categorical 
and continuous data together, a typical---but inappropriate---strategy 
is to recode the continuous data into categories 
such as dichotomization, trichotomization, 
or other (often arbitrary) binning strategies. 
Furthermore, ordinal and Likert scale data---such 
as responses on many cognitive, behavioral, clinical, 
and survey instruments---are often incorrectly treated 
as metric or continuous values [@burkner_ordinal_nodate]. 
When it comes to genetic data, 
such as single nucleotide polymorphims (SNPs), 
the data are 
almost always
recoded 
by
counting 
the number of the minor homozygote to give: 0 for the major homozygote 
(two copies of the most frequent of the two alleles), 
1 for the heterozygote, and 2 for the minor homozygote. 
This {0, 1, 2} recoding of genotypes (1) 
assumes additive linear effects based on the minor homozygote 
and (2) is often treated as metric/continuous values 
(as opposed to categorical or ordinal), 
even when known effects of risk are neither linear nor additive, 
such as haplotypic effects [@vormfelde_value_2007]
nor exclusively based on the minor homozygotes, 
such as ApoE in Alzheimer's Disease [@genin_apoe_2011].
Interestingly other, less restrictive, models 
(e.g., dominant, recessive,  genotypic)
perform better [@lettre2007genetic] than the additive model, but these
are rarely used.

Here we introduce partial
least squares-correspondence analysis-regression (PLS-CA-R): 
a latent variable regression modeling approach suited 
for the analysis of complex data sets. 
We first show that PLS-CA-R  generalizes PLS regression 
[@wold_soft_1975; @wold_collinearity_1984; @tenenhaus_regression_1998; 
@abdi_partial_2010-1], CA [@greenacre_theory_1984; 
@greenacre_correspondence_2010-1; @lebart_multivariate_1984], 
and PLS-CA [@beaton_partial_2016]---which is
the "correlation" companion and basis of
PLS-CA-R.
We then show that  PLS-CA-R is 
a data-type general PLS regression method
based on the generalized singular value decomposition (GSVD)
that combines the features of CA 
(to accommodate multiple data types)
with the features of PLS-R 
(as a regression method generalizing ordinary least squares regression
when its assumptions are not met). 

We illustrate the multiple uses of PLS-CA-R, 
with data from the Alzheimer's Disease Neuroimaging Initiative (ADNI). 
These data include: 
diagnosis data (mutually exclusive categories), 
SNPs (genotypes are categorical), 
multiple behavioral or clinical instruments 
(that could be ordinal, categorical, or continuous), 
and several neuroimaging measures and indices 
(generally either continuous or non-negative). 
PLS-CA-R
can 1) accommodate these different data types 
in a predictive or fitting framework, 2) 
regress (i.e., residualize) covariates 
out of mixed and collinear data, 
and 3) reveal latent variables
within a well-established framework. 

Finally, 
we show that PLS-CA-R can be generalized 1) 
to handle multiple data types, 2) 
various optimization schemes (e.g., covariance as in PLS or correlation 
as in canonical correlation), 
3) 
various transformations for alternate metrics, 
and 4) ridge-like regularization and 5) multiple PLS algorithms. 

This paper is organized as follows. 
In Section \ref{section:PLSCAR} we introduce PLS-CA-R. 
Next, in Section \ref{section:appex}, 
we illustrate PLS-CA-R on the TADPOLE challenge
(https://tadpole.grand-challenge.org/) 
and additional genetics data from ADNI across three examples: 
1) a simple discriminant example with categorical data, 
2) a mixed data example that requires residualization, 
and 3) a larger example of multiple genetic markers 
and whole brain tracer uptake (non-negative values). 
Finally in Section \ref{section:Disc} we discuss PLS-CA-R, and 
show how PLS-CA-R generalizes the PLS framework 
to multiple optimization problems, algorithms, metrics, 
and ridge-like regularization. 


# Partial least squares-correspondence analysis-regression
\label{section:PLSCAR}

Here we present the generalization of partial 
least square-regression (PLS-R) 
to multiple correspondence analysis (MCA) 
and correspondence analysis (CA)-like methods 
that generally apply to categorical (nominal) data. 
Via CA, we can also generalize to other data types 
including mixed types 
(e.g., categorical, ordinal, continuous, contingency). 

## PLS algorithms

There exist three commonly used PLS algorithms: (1) PLS "correlation"
decomposition [@krishnan_partial_2011; @bookstein1994partial;
@mcintosh_spatial_1996]---also known as PLSSVD
[@tenenhaus_regression_1998] or Tucker's Interbattery Factor Analysis
[@tucker_inter-battery_1958], (2) PLS "canonical" decompostion
[@tenenhaus_regression_1998], and (3) PLS "regression" [@wold_soft_1975;
@wold_collinearity_1984; @wold_pls-regression_2001]. PLS correlation
decomposition is a symmetric method where neither data table plays a privileged
(or predictive) role, and is performed with a single pass of the singular value
decomposition (SVD). PLS canonical decomposition is also symmetric, but makes
use of the SVD iteratively and deflates both data tables in each iteration. PLS
regression decomposition is an asymmetric method where one data table is
privileged (i.e., treated as predictors) and also makes use of the SVD iteratively with
deflation of both data tables.

## Notation

Bold uppercase letters denote matrices
(e.g., $\mathbf{X}$), bold lowercase letters denote vectors 
(e.g., $\bf{x}$), and italic lowercase letters 
denote specific elements (e.g., $x$). 
Upper case italic letters (e.g., $I$) 
denote cardinality, size, or length 
where a lower case italic (e.g., $i$) 
denotes a specific value of an index. 
A generic element of
matrix $\mathbf{X}$ would be denoted $x_{i,j}$. 
Common letters of varying type faces, 
for example ${\bf X}$, $\bf{x}$, $x_{i,j}$, 
come from the same data structure. 
A preprocessed or transformed version of a matrix 
${\mathbf X}$ is denoted ${\mathbf Z}_{\mathbf X}$. 
Vectors are assumed to be column vectors unless otherwise specified. 
Two matrices side-by-side denotes standard matrix multiplication 
(e.g., $\bf{X}\bf{Y}$). 
The operator
 $\odot$ denotes element-wise (Hadamard) multiplication and
 $\oslash$ denotes element-wise (Hadamard) division.
 The matrix ${\bf I}$ denotes the identity matrix,
 $\mathbf{1}$ denotes a vector 1's and ${\mathbf 0}$ is a null matrix (all entries are $0$).
 Superscript $^{T}$ denotes the transpose operation, 
 superscript $^{-1}$ denotes standard matrix inversion,
 and superscript $^{+}$ denotes the Moore-Penrose pseudo-inverse.
The diagonal operator, denoted $\mathrm{diag\{\}}$, 
transforms a vector into a diagonal matrix, 
or extracts the diagonal of a matrix to produce a vector.

## The SVD, GSVD, CA, and GPLSSVD

\label{section:GSVDCA}

Let ${\mathbf X}$ be a data matrix with $I$ rows and $J$ columns,
${\mathbf X}$ is preprocessed in some way to give 
${\mathbf Z}_{\mathbf X}$. 
The
singular value decomposition (SVD) decomposes 
${\mathbf Z}_{\mathbf X}$ as
\begin{equation}\label{eq:svd}
{\mathbf Z}_{\mathbf X} = 
{\mathbf U} {\boldsymbol \Delta} {\mathbf V}^{T}
\textrm{ with } {\mathbf U}^{T}{\mathbf U} 
= {\mathbf I} = {\mathbf V}^{T}{\mathbf V},
\end{equation}
where ${\mathbf Z}_{\mathbf X}$ is of rank $A$ 
(with $A \leq \min(I,J)$) and 
${\boldsymbol \Delta}$ is the $A \times A$ 
diagonal matrix of the singular values, and 
${\boldsymbol \Lambda} = {\boldsymbol \Delta}^2$ 
is the $A \times A$ diagonal matrix of the eigenvalues. 
Matrices
${\mathbf U}$ and ${\mathbf V}$ store (respectively)
the left and right singular vectors of ${\mathbf Z}$. 
Component (a.k.a. factor) 
scores
for the $I$ rows and $J$ columns of ${\mathbf Z}_{\mathbf X}$
are computed as
 ${\mathbf F}_{I} = {\mathbf U}{\boldsymbol \Delta}$ 
${\mathbf F}_{J} = {\mathbf V}{\boldsymbol \Delta}$.

The \emph{generalized} singular value decomposition (GSVD) 
generalizes the SVD
by integrating constraints 
(expressed by positive definite matrices) also called *metric*
(because these matrices define a metric in a generalized Euclidean space)
imposed on the rows and columns of the matrix to be decomposed.
Specifically, if ${\mathbf M}_{{\mathbf X}}$ 
(respectively 
${\mathbf W}_{{\mathbf X}}$) 
is an $I\times I$ (respectively $J\times J$) 
positive definite matrix,
 the GSVD decomposes 
${\mathbf Z}_{\mathbf X}$ as 
\begin{equation}\label{eq:gsvd}
{\mathbf Z}_{\mathbf X} = {\mathbf P} 
{\boldsymbol \Delta} {\mathbf Q}^{T} 
\textrm{ with }
{\mathbf P}^{T}{\mathbf M}_{{\mathbf X}}{\mathbf P} = {\mathbf I} = {\mathbf Q}^{T}{\mathbf W}_{{\mathbf X}}{\mathbf Q}
\end{equation}
where ${\mathbf Z}_{\mathbf X}$ is of rank $A$ 
and ${\boldsymbol \Delta}$ is the $A \times A$ 
diagonal matrix of the (generalized) singular values
and ${\mathbf P}$ and ${\mathbf Q}$ are the *generalized* 

Correspondence analysis (CA) is a technique akin to PCA---originally designed for the analysis of contingency tables---and analyzes deviations to independence. See @greenacre_theory_1984, @greenacre_correspondence_2010-1, and @lebart_multivariate_1984 for detailed explanations of CA, and then see @escofier-cordier_analyse_1965 and @benzecri_analyse_1973 for the origins and early developments of CA. CA analyzes an $I \times J$ matrix ${\mathbf X}$ whose entries are all non-negative. CA is performed with the GSVD as follows. 
First the *observed* probability matrix is computed as
${\mathbf O}_{\mathbf X} = 
{\mathbf X} \times ({\mathbf 1}^{T}{\mathbf X} {\mathbf 1})^{-1}$ 
The marginal probabilities from the observed matrix 
are then computed as 
\begin{equation}
{\mathbf m}_{\mathbf X} = {\mathbf O}_{\mathbf X}{\mathbf 1} 
\text{ and } 
{\mathbf w}_{\mathbf X} = ({\mathbf 1}^{T}{\mathbf O}_{\mathbf X})^{T}.
\end{equation}
The *expected* matrix is computed as 
${\mathbf E}_{\mathbf X} 
= {\mathbf m}_{\mathbf X}{\mathbf w}_{\mathbf X}^{T}$. 
The *deviation* 
from independence matrix is then
\begin{equation}
{\mathbf Z}_{\mathbf X} 
= {\mathbf O}_{\mathbf X} - {\mathbf E}_{\mathbf X}.
\end{equation}
Finally, CA 
is obtained from 
\begin{equation}\label{eq:CAasGSVD}
\mathrm{GSVD(} {\mathbf M}_{\mathbf X}^{-1}, 
{\mathbf Z}_{\mathbf X}, {\mathbf W}_{\mathbf X}^{-1} \mathrm{)}
\textrm{ with }
{\mathbf M}_{\mathbf X} 
=  \mathrm{diag\{} {\mathbf m}_{\mathbf X} 
\mathrm{\}} \text{ and } {\mathbf W}_{\mathbf X} 
= \mathrm{diag\{} {\mathbf w}_{\mathbf X} \mathrm{\}}.
\end{equation}


## From the triplet to the sextuplet 

We now introduce an extension of the GSVD and its triplet concept for PLS, called the "GPLSSVD sextuplet" to decompose the the relationship between two matrices each with the same $I$ observations (along the rows): ${\mathbf X}$ with $J$ columns and ${\mathbf Y}$ with $K$ columns, where ${\mathbf Z}_{\mathbf X}$ and ${\mathbf Z}_{\mathbf Y}$ are preprocessed versions of ${\mathbf X}$ and ${\mathbf Y}$, respectively. The "GPLSSVD sextuplet" takes the form of $\mathrm{GPLSSVD(} {\mathbf M}_{\mathbf X}, {\mathbf Z}_{\mathbf X}, {\mathbf W}_{\mathbf X}, {\mathbf M}_{\mathbf Y}, {\mathbf Z}_{\mathbf Y}, {\mathbf W}_{\mathbf Y} \mathrm{)}$. The $\mathrm{GPLSSVD(} {\mathbf M}_{\mathbf X}, {\mathbf Z}_{\mathbf X}, {\mathbf W}_{\mathbf X}, {\mathbf M}_{\mathbf Y}, {\mathbf Z}_{\mathbf Y}, {\mathbf W}_{\mathbf Y} \mathrm{)}$ decomposes the matrix ${\mathbf Z}_{\mathbf R} = ({\mathbf M}_{\mathbf X}^{\frac{1}{2}}{\mathbf Z}_{\mathbf X})^{T}  {\mathbf M}_{\mathbf Y}^{\frac{1}{2}} {\mathbf Z}_{\mathbf Y}$ as

\begin{equation}
{\mathbf Z}_{\mathbf R} = {\mathbf P} {\boldsymbol \Delta} {\mathbf Q}^{T}
\textrm{ with }
{\mathbf P}^{T}{\mathbf W}_{\mathbf X}{\mathbf P} = {\mathbf I} =
{\mathbf Q}^{T}{\mathbf W}_{\mathbf Y}{\mathbf Q}.
\end{equation}

From this decomposition, the GPLSSVD creates latent variables as 

\begin{equation}
{\mathbf L}_{\mathbf X} 
= {\mathbf Z}_{\mathbf X}{\mathbf W}_{\mathbf X}{\mathbf P} 
\textrm{ and } 
{\mathbf L}_{\mathbf Y} = 
{\mathbf Z}_{\mathbf Y}{\mathbf W}_{\mathbf Y}{\mathbf Q}
\textrm{ where }
{\mathbf L}_{\mathbf X}^{T} {\mathbf L}_{\mathbf Y} 
= {\boldsymbol \Delta}. 
\end{equation}


When ${\mathbf X}$ and ${\mathbf Y}$ are column-wise centered normalized and when all constraint matrices are equal to the identity matrix---i.e., $\mathrm{GPLSSVD(} {\mathbf I}, {\mathbf Z}_{\mathbf X}, {\mathbf I}, {\mathbf I}, {\mathbf Z}_{\mathbf Y}, {\mathbf I} \mathrm{)}$---the GPLSSVD implements the "PLS correlation" decomposition [@krishnan_partial_2011; @bookstein1994partial; @mcintosh_spatial_1996], also known as PLSSVD [@tenenhaus_regression_1998], co-inertia [@doledec1994,@dray2014], and originally as Tucker's interbattery factor analysis [@tucker_inter-battery_1958]. Finally, we also introduce a small modification of the "triplet" and "sextuplet" notations as a "quadruplet" and a "septuplet" that indicate the desired rank to be returned by the GSVD or GPLSSVD. For example, if we want only one component from either approach we would indicate the desired rank to return as $\mathrm{GSVD(} {\mathbf M}_{{\mathbf X}}, {\mathbf Z}_{\mathbf X}, {\mathbf W}_{{\mathbf X}}, 1 \mathrm{)}$ and $\mathrm{GPLSSVD(} {\mathbf M}_{\mathbf X}, {\mathbf Z}_{\mathbf X}, {\mathbf W}_{\mathbf X}, {\mathbf M}_{\mathbf Y}, {\mathbf Z}_{\mathbf Y}, {\mathbf W}_{\mathbf Y}, 1 \mathrm{)}$. Both the GSVD and GPLSSVD in these cases would return only one set of singular vectors, generalized singular vectors, and component scores, and one singular value; for GPLSSVD it would return only one pair of latent variables.


```{r echo=F, results="asis", include=T, message=FALSE, warning=FALSE}
  
  age.doubled <- escofier_coding(as.matrix(TADPOLE.fin$AGE),scale=T)
  colnames(age.doubled) <- c('AGE-','AGE+')
  
  edu.thermometer <- thermometer_coding(as.matrix(TADPOLE.fin$PTEDUCAT))
  colnames(edu.thermometer) <- c('EDU-','EDU+')
  
  beh.brain.confounds <- cbind(make_data_disjunctive(as.matrix(TADPOLE.fin[,c("PTGENDER")])),age.doubled,edu.thermometer)
  colnames(beh.brain.confounds) <- gsub("1\\.","",colnames(beh.brain.confounds))
  rownames(beh.brain.confounds) <- rownames(TADPOLE.fin)
  
  orig.table <- head(TADPOLE.fin[,c("PTGENDER","AGE","PTEDUCAT")])
  colnames(orig.table) <- c("SEX","AGE","EDU")
  dt <- cbind(orig.table, round(head(beh.brain.confounds),digits=2))
    rownames(dt) <- paste("SUBJ", 1:nrow(dt), sep=" ")

  kable(dt, "latex", caption = "\\label{table:disj} An example of disjunctive (SEX) and pseudo-disjunctive (AGE, EDU) coding through the Escofier or fuzzy transforms. For disjunctive an pseudo-disunctive data, each variable has a row-wise sum of 1 across its respective columns, and thus the row sums across the table are the number of original variables.", booktabs = T) %>%
  kable_styling(latex_options =c("hold_position")) %>%
    add_header_above(c(" "= 4, "SEX" = 2, "AGE" = 2, "EDU" = 2)) %>%
  add_header_above(c(" ", "Original coding" = 3, "Disjunctive and pseudo-disjunctive coding" = 6))

```


## PLS-CA-R
\label{section:plscar_form}

For simplicity assume in the following formulation that ${\mathbf X}$ and ${\mathbf Y}$ are both complete disjunctive tables as seen in Table \ref{table:disj} (see SEX columns) or Table \ref{table:snps_models_disj}. This formulation also applies generally to non-negative data (see later sections). We define observed matrices for ${\mathbf X}$ and ${\mathbf Y}$ as

\begin{equation}
\begin{aligned}
{\mathbf O}_{\mathbf X} = {\mathbf X} \times ({\mathbf 1}^{T}{\mathbf X} {\mathbf 1})^{-1}, \\
{\mathbf O}_{\mathbf Y} = {\mathbf Y} \times ({\mathbf 1}^{T}{\mathbf Y} {\mathbf 1})^{-1}
\label{eq:observedXY}
\end{aligned}
\end{equation}
Next we compute marginal probabilities for the rows and columns. We compute row marginal probabilities as 
\begin{equation}
{\mathbf m}_{\mathbf X} = {\mathbf O}_{\mathbf X}{\mathbf 1} \text{ and } {\mathbf m}_{\mathbf Y} = {\mathbf O}_{\mathbf Y}{\mathbf 1},
\label{eq:xy_rowvecs}
\end{equation}
and column probabilities as 
\begin{equation}
{\mathbf w}_{\mathbf X} = ({\mathbf 1}^{T}{\mathbf O}_{\mathbf X})^{T} \text{ and } {\mathbf w}_{\mathbf Y} = ({\mathbf 1}^{T}{\mathbf O}_{\mathbf Y})^{T},
\label{eq:weightmats_v1}
\end{equation}
We then define expected matrices as
\begin{equation}
{\mathbf E}_{\mathbf X} = {\mathbf m}_{\mathbf X}{\mathbf w}_{\mathbf X}^{T} \text{ and } {\mathbf E}_{\mathbf Y} = {\mathbf m}_{\mathbf Y}{\mathbf w}_{\mathbf Y}^{T},
\label{eq:models}
\end{equation}
and deviation matrices as
\begin{equation}
{\mathbf Z}_{\mathbf X} = {\mathbf O}_{\mathbf X} - {\mathbf E}_{\mathbf X} \text{ and } {\mathbf Z}_{\mathbf Y} = {\mathbf O}_{\mathbf Y} - {\mathbf E}_{\mathbf Y},
\label{eq:plscar_Zs}
\end{equation}

For PLS-CA-R we have row and column weights of ${\mathbf M}_{\mathbf X} = \mathrm{diag\{}{\mathbf m}_{\mathbf X} \mathrm{\}}$, ${\mathbf M}_{\mathbf Y} = \mathrm{diag\{}{\mathbf m}_{\mathbf Y} \mathrm{\}}$, ${\mathbf W}_{\mathbf X} = \mathrm{diag\{}{\mathbf w}_{\mathbf X} \mathrm{\}}$, and ${\mathbf W}_{\mathbf Y} = \mathrm{diag\{}{\mathbf w}_{\mathbf Y} \mathrm{\}}$. PLS-CA-R makes use of the rank 1 GPLSSVD iteratively---$\mathrm{GPLSSVD(} {\mathbf M}_{\mathbf X}^{-1}, {\mathbf Z}_{\mathbf X}, {\mathbf W}_{\mathbf X}^{-1}, {\mathbf M}_{\mathbf Y}^{-1}, {\mathbf Z}_{\mathbf Y}, {\mathbf W}_{\mathbf Y}^{-1}, 1 \mathrm{)}$---and works as follows. 

First we have the cross-product ${\mathbf Z}_{\mathbf R} = ({\mathbf M}_{\mathbf X}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf X}{\mathbf W}_{\mathbf X}^{-\frac{1}{2}})^{T}({\mathbf M}_{\mathbf Y}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf Y}{\mathbf W}_{\mathbf Y}^{-\frac{1}{2}})$, where
\begin{equation}
{\mathbf Z}_{\mathbf R} = {\mathbf U} {\boldsymbol \Delta} {\mathbf V}^{T}.
\label{eq:the_svd_for_plscar}
\end{equation}
Because we make use of the rank 1 solution iteratively, we only retain the first vectors and values from Eq. \ref{eq:the_svd_for_plscar}. Thus we distinguish what we retain as $\tilde\delta$, $\widetilde{\mathbf u}$, $\widetilde{\mathbf v}$, $\widetilde{\mathbf p}$, $\widetilde{\mathbf q}$, and $\widetilde{\mathbf f}_{J}$, and $\widetilde{\mathbf f}_{K}$. We then compute the latent variables as
\begin{equation}
\begin{aligned}
{\boldsymbol \ell}_{\mathbf X} = ({\mathbf M}_{\mathbf X}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf X}{\mathbf W}_{\mathbf X}^{-\frac{1}{2}})\widetilde{\mathbf u} \text{ and } {\boldsymbol \ell}_{\mathbf Y} = ({\mathbf M}_{\mathbf Y}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf Y}{\mathbf W}_{\mathbf Y}^{-\frac{1}{2}})\widetilde{\mathbf v}.
\label{eq:lvs}
\end{aligned}
\end{equation}
Next we compute ${\mathbf t}_{\mathbf X} = {\boldsymbol \ell}_{\mathbf X} \times {{\lvert\lvert {\boldsymbol \ell}_{\mathbf X} \rvert\rvert}^{-1}}$, $b = {\boldsymbol \ell}_{\mathbf Y}^{T}{\mathbf t}_{\mathbf X}$, and $\widehat{\mathbf u} = {\mathbf t}_{\mathbf X}^{T} ({\mathbf M}_{\mathbf X}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf X}{\mathbf W}_{\mathbf X}^{-\frac{1}{2}})$. We use ${\mathbf t}_{\mathbf X}$, $b$, and $\widehat{\mathbf u}$ to compute rank 1 "predicted" versions of ${\mathbf Z}_{\mathbf X}$ and ${\mathbf Z}_{\mathbf Y}$ as 

\begin{equation}
\widehat{\mathbf Z}_{{\mathbf X},1} = {\mathbf M}_{\mathbf X}^{\frac{1}{2}}({\mathbf t}_{\mathbf X}\widehat{\mathbf u}^{T}){\mathbf W}_{\mathbf X}^{\frac{1}{2}} \text{ and } \widehat{\mathbf Z}_{{\mathbf Y},1} = {\mathbf M}_{\mathbf Y}^{\frac{1}{2}}(b{\mathbf t}_{\mathbf X}\widetilde{\mathbf v}^{T}){\mathbf W}_{\mathbf Y}^{\frac{1}{2}}.
\label{eq:rank1_preds_plscar}
\end{equation}
Finally, we deflate ${\mathbf Z}_{\mathbf X}$ and ${\mathbf Z}_{\mathbf Y}$ as ${\mathbf Z}_{\mathbf X} = {\mathbf Z}_{\mathbf X} - \widehat{\mathbf Z}_{{\mathbf X},1}$ and ${\mathbf Z}_{\mathbf Y} = {\mathbf Z}_{\mathbf Y} - \widehat{\mathbf Z}_{{\mathbf Y},1}$. We then repeat the iterative procedure with these deflated ${\mathbf Z}_{\mathbf X}$ and ${\mathbf Z}_{\mathbf Y}$. The computations outlined above are performed for $C$ iterations where: (1) $C$ is some pre-specified number of intended latent variables where $C \leq A$ where $A$ is the rank of $\widetilde{\mathbf Z}_{\mathbf X}$ or (2) when ${\mathbf Z}_{\mathbf X} = {\mathbf 0}$ or ${\mathbf Z}_{\mathbf Y} = {\mathbf 0}$. Upon the stopping condition we would have $C$ components, and would have collected any vectors into corresponding matrices. Those matrices are

* two $C \times C$ diagonal matrices ${\mathbf B}$ and $\widetilde{\boldsymbol \Delta}$ with each $b$ and $\tilde\delta$ on the diagonal with zeros off-diagonal,

* the $I \times C$ matrices ${\mathbf L}_{\mathbf X}$, ${\mathbf L}_{\mathbf Y}$, and ${\mathbf T}_{\mathbf X}$, 

* the $J \times C$ matrices $\widetilde{\mathbf U}$, $\widehat{\mathbf U}$, $\widetilde{\mathbf P}$, and $\widetilde{\mathbf F}_{J}$, and

* the $K \times C$ matrices $\widetilde{\mathbf V}$, $\widetilde{\mathbf Q}$, $\widetilde{\mathbf F}_{K}$.

The algorithm for PLS-CA-R is presented in Algorithm \ref{algo:plscar} in Section \ref{section:Disc}. We present Algorithm \ref{algo:plscar} as a "generalized partial least squares regression" by way of the GPLSSVD sextuplet. We discuss the generalized aspects of the algorithm in more detail in Section \ref{section:Disc}.


## Maximization in PLS-CA-R

PLS-CA-R maximizes the common information between ${\mathbf Z}_{\mathbf X}$ and ${\mathbf Z}_{\mathbf Y}$ such that

\begin{equation}
\begin{aligned}
\underset{{\boldsymbol \ell}_{\mathbf X},{\boldsymbol \ell}_{\mathbf Y}}{\operatorname{arg\,max}} = {\boldsymbol \ell}_{\mathbf X}^{T}{\boldsymbol \ell}_{\mathbf Y} = 
({\mathbf M}_{X}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf X}{\mathbf W}_{X}^{-1}\widetilde{\mathbf p})^{T}({\mathbf M}_{Y}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf Y}{\mathbf W}_{Y}^{-1}\widetilde{\mathbf q}) = \\
({\mathbf M}_{X}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf X}{\mathbf W}_{X}^{-\frac{1}{2}}{\mathbf W}_{X}^{-\frac{1}{2}}\widetilde{\mathbf p})^{T}({\mathbf M}_{Y}^{-\frac{1}{2}}{\mathbf Z}_{\mathbf Y}{\mathbf W}_{Y}^{-\frac{1}{2}}{\mathbf W}_{Y}^{-\frac{1}{2}}\widetilde{\mathbf q}) = \\
( \widetilde{\mathbf Z}_{\mathbf X} {\mathbf W}_{X}^{-\frac{1}{2}}\widetilde{\mathbf p})^{T}(\widetilde{\mathbf Z}_{\mathbf Y}{\mathbf W}_{Y}^{-\frac{1}{2}}\widetilde{\mathbf q}) = 
( \widetilde{\mathbf Z}_{\mathbf X} {\mathbf W}_{X}^{-\frac{1}{2}}{\mathbf W}_{X}^{\frac{1}{2}}\widetilde{\mathbf u})^{T}(\widetilde{\mathbf Z}_{\mathbf Y}{\mathbf W}_{Y}^{-\frac{1}{2}}{\mathbf W}_{Y}^{\frac{1}{2}}\widetilde{\mathbf v}) = \\ 
(\widetilde{\mathbf Z}_{\mathbf X}\widetilde{\mathbf u})^{T}(\widetilde{\mathbf Z}_{\mathbf Y}\widetilde{\mathbf v}) = \widetilde{\mathbf u}\widetilde{\mathbf Z}_{\mathbf X}^{T}\widetilde{\mathbf Z}_{\mathbf Y}\widetilde{\mathbf v} = \widetilde{\mathbf u}{\mathbf Z}_{\mathbf R}\widetilde{\mathbf v} = \widetilde{\mathbf u}{\mathbf U}{\boldsymbol \Delta}{\mathbf V}\widetilde{\mathbf v}  = \widetilde\delta,
\end{aligned}
\end{equation}
where $\widetilde\delta$ is the first singular value from ${\mathbf \Delta}$ for each $c$ step. PLS-CA-R maximization is subject to the orthogonality constraint that ${\boldsymbol \ell}_{{\mathbf X},c}^{T}{\boldsymbol \ell}_{{\mathbf X},c'} = 0$ when $c \neq c'$. This orthogonality constraint propagates through to many of the vectors and matrices associated with ${\mathbf Z}_{\mathbf X}$ where ${\mathbf T}_{\mathbf X}^{T}{\mathbf T}_{\mathbf X} = \widetilde{\mathbf P}^{T}{\mathbf W}_{J}^{-1}\widetilde{\mathbf P} = \widetilde{\mathbf U}^{T}\widetilde{\mathbf U} = {\mathbf I}$; these orthogonality constraints do not apply to the various vectors and matrices associated with ${\mathbf Y}$.


## Decomposition and reconstitution
\label{section:recresp}

PLS-CA-R is a "double decomposition" where
\begin{equation}
\begin{aligned}
{\mathbf Z}_{\mathbf X} = {\mathbf M}^{\frac{1}{2}}_{\mathbf X}{\mathbf T}\widehat{\mathbf U}^{T}{\mathbf W}^{\frac{1}{2}}_{\mathbf X} \text{ and }\\
\widehat{{\mathbf Z}}_{\mathbf Y} = {\mathbf M}^{\frac{1}{2}}_{\mathbf Y}{\mathbf T}_{\mathbf X}{\mathbf B}\widetilde{\mathbf V}^{T}{\mathbf W}^{\frac{1}{2}}_{\mathbf Y} = {\mathbf M}^{\frac{1}{2}}_{\mathbf Y}\widetilde{\mathbf Z}_{\mathbf X}\widehat{\mathbf U}^{{T}{+}}{\mathbf B}\widetilde{\mathbf V}^{T}{\mathbf W}^{\frac{1}{2}}_{\mathbf Y},
\label{eq:doubledecomp}
\end{aligned}
\end{equation}
where $\widetilde{\mathbf Z}_{\mathbf X} = {\mathbf T}\widehat{\mathbf U}^{T}$ and $\widehat{\widetilde{\mathbf Z}}_{\mathbf Y} = {\mathbf T}_{\mathbf X}{\mathbf B}\widetilde{\mathbf V}^{T} = \widetilde{\mathbf Z}_{\mathbf X}\widehat{\mathbf U}^{{T}{+}}{\mathbf B}\widetilde{\mathbf V}^{T}$. PLS-CA-R, like PLS-R, provides the same estimated predicted values as OLS under the conditions that ${\bf Z}_{\bf X}$ is (1) full rank, (2) non-singular, (3) not excessively multicollinear:
\begin{equation}
\widehat{{\mathbf Z}}_{\mathbf Y} = {\mathbf M}^{\frac{1}{2}}_{\mathbf Y}{\mathbf T}_{\mathbf X}{\mathbf B}\widetilde{\mathbf V}^{T}{\mathbf W}^{\frac{1}{2}}_{\mathbf Y} = \widetilde{\mathbf Z}_{\mathbf X} (\widetilde{\mathbf Z}_{\mathbf X}^{T}\widetilde{\mathbf Z}_{\mathbf X})^{+} \widetilde{\mathbf Z}_{\mathbf X}^T {\mathbf Z}_{\mathbf Y},
\label{ols_equivalence}
\end{equation}
where ${\mathbf T}_{\mathbf X}{\mathbf B}\widetilde{\mathbf V}^{T} = \widetilde{\mathbf Z}_{\mathbf X} (\widetilde{\mathbf Z}_{\mathbf X}^{T}\widetilde{\mathbf Z}_{\mathbf X})^{+} \widetilde{\mathbf Z}_{\mathbf X}^T\widetilde{\mathbf Z}_{\mathbf Y}$. This connection to OLS shows how to residualize (i.e., "regress out" or "correct") for covariates, akin to how residuals are computed in OLS. We do so with the original ${\mathbf Z}_{\mathbf Y}$ as ${\mathbf Z}_{\mathbf Y} - \widehat{\mathbf Z}_{\mathbf Y}$. PLS-CA-R produces both a predicted and a residualized version of ${\mathbf Y}$. Recall that $\widehat{{\mathbf Z}}_{\mathbf Y} = {\mathbf M}^{\frac{1}{2}}_{\mathbf Y}{\mathbf T}_{\mathbf X}{\mathbf B}\widetilde{\mathbf V}^{T}{\mathbf W}^{\frac{1}{2}}_{\mathbf Y}$. We compute a reconstituted form of ${\mathbf Y}$ as 
\begin{equation}
\widehat{\mathbf Y} = (\widehat{{\mathbf Z}}_{\mathbf Y} + {\mathbf E}_{\mathbf Y}) \times ({\mathbf 1}^{T}{\mathbf Y}{\mathbf 1}),
\label{eq:Yhat}
\end{equation}
which is the opposite steps of computing the deviations matrix. We add back in the expected values and then scale the data by the total sum of the original matrix. The same can be done for residualized values (i.e., "error") as
\begin{equation}
{\mathbf Y}_{\epsilon} = [({\mathbf Z}_{\mathbf Y} - \widehat{{\mathbf Z}}_{\mathbf Y}) + {\mathbf E}_{\mathbf Y}] \times ({\mathbf 1}^{T}{\mathbf Y}{\mathbf 1}).
\label{eq:Yresid}
\end{equation}
Typically, ${\mathbf E}_{\mathbf Y}$ is derived the data (as noted in Eq. \ref{eq:models}). However, the reconstituted space could come from any model by way of generalized correspondence analysis (GCA) [@escofier1983analyse; @escofier1984analyse; @grassi1994correspondence; @beaton2018generalization]. With GCA we could use any reasonable alternates of ${\mathbf E}_{\mathbf Y}$ as the model, which could be obtained from, for examples, known priors, a theoretical model, out of sample data, or population estimates. CA can then be applied directly to either $\widehat{\mathbf Y}$ or ${\mathbf Y}_{\epsilon}$. The same reconstitution procedures can be applied fitted and residualized versions of ${\mathbf X}$ as well.


## Concluding remarks

Now that we have formalized PLS-CA-R, we want to point out small variations, some caveats, and some additional features We go into more detail in later sections on larger variations and broader generalizations.


In PLS-CA-R (and PLS-R) each subsequent $\widetilde{\delta}$ is not guaranteed to be smaller than the previous, with the exception that all $\widetilde \delta$ are smaller than the first. This is a by-product of the iterative process and the deflation steps that does not occur with just a single pass of the SVD or GSVD (i.e., PLS-correlation decomposition). This problem poses two issues: (1) visualization of component scores and (2) explained variance. For visualization of the component scores---which use $\widetilde \delta$---there is an alternative computation: ${\mathbf F}^{'}_{J} = {\mathbf W}_{J}\widetilde{\mathbf P}$ and ${\mathbf F}^{'}_{K} = {\mathbf W}_{K}\widetilde{\mathbf Q}$. This alternative is referred to as "asymmetric component scores" in the correspondence analysis literature [@abdi2014correspondence; @greenacre1993biplots]. Additionally, instead of computing the variance per component or latent variable, we can instead compute the amount of variance explained by each component in $\mathbf X$ and $\mathbf Y$. To do so we require the sum of the eigenvalues of each of the respective matrices per iteration via CA (with the GSVD). Before the first iteration of PLS-CA-R we obtain the full variance (i.e., the sum of the eigenvalues) of each matrix from $\mathrm{GSVD(} {\mathbf M}^{-1}_{\mathbf X}, {\mathbf Z}_{\mathbf X}, {\mathbf W}^{-1}_{\mathbf X} \mathrm{)}$ and $\mathrm{GSVD(} {\mathbf M}^{-1}_{\mathbf Y}, {\mathbf Z}_{\mathbf Y}, {\mathbf W}^{-1}_{\mathbf Y} \mathrm{)}$, which we respectively refer to as ${\phi}_{\bf X}$ and ${\phi}_{\bf Y}$ We can compute the sum of the eigenvalues for each deflated version of ${\mathbf Z}_{\mathbf X}$ and ${\mathbf Z}_{\mathbf Y}$ through the GSVD just as above, referred to as ${\phi}_{{\bf X},c}$ and ${\phi}_{{\bf Y},c}$. For each $c$ component the proportion of explained variance for each matrix is $\frac{{\phi}_{\bf X} - {\phi}_{{\bf X},c}}{{\phi}_{\bf X}}$ and $\frac{{\phi}_{\bf Y} - {\phi}_{{\bf Y},c}}{{\phi}_{\bf Y}}$.


In our formulation, the weights we use are derived from the $\chi^2$ assumption of independence. However nearly any choices of weights could be used, so long as the weight matrices are at least positive semi-definite (which requires the use of a generalized inverse). Alternate row weights (i.e., ${\mathbf M}_{\mathbf X}$ or ${\mathbf M}_{\mathbf Y}$) were chosen, then the fitted values and residuals are no longer guaranteed to be orthogonal (the same condition is true in weighted OLS).  

Finally, though we formalized PLS-CA-R as a method for categorical (nominal) data coded in complete disjunctive format (as seen in Table \ref{table:disj}---see SEX columns---or Table \ref{table:snps_models_disj}), PLS-CA-R can easily accomodate various data types without loss of information. Specifically, both continuous and ordinal data can be handled with relative ease and in a "pseudo-disjunctive" format, also referred to as "fuzzy coding" where complete disjunctive would be a "crisp coding" [@greenacrefuzzy]. We explain exactly how to handle various data types as Section \ref{section:appex} progresses, which reflects more "real world" problems: complex, mixed data types, and multi-source data.


# BRING ALGO AND OTHER POINTS HERE BUT IN BRIEF. AND TRUNCATE ABOVE. ALSO RENAME

# Applications & Examples
\label{section:appex}

In this section we provide examples with real data from the Alzheimer's Disease Neuroimaging Initiative (ADNI). These examples illustrate how to approach mixed data with PLS-CA-R and the multiple uses of PLS-CA-R (e.g., for analyses, as a residualization procedure). We present three sets of analyses. First we introduce of PLS-CA-R through a typical example where we want predict genotypes (categorical) from groups (categorical). Next we show how to predict genotypes from a small set of behavioral and brain variables. This second example serves multiple purposes: (1) how to recode and analyze mixed data (categorical, ordinal, and continuous), (2) how to use PLS-CA-R, and (3) how to use PLS-CA-R as residualization technique to remove effects from data prior to subsequent analyses. Finally, we present a larger analysis with the goal to predict genotypes from cortical uptake of AV45 (i.e., a radiotracer) PET scan for beta-amyloid ("A$\beta$") deposition. This final example also makes use of residualization as illustrated in the second example. 


## ADNI Data
\label{section:data}

Data used in the preparation of this article come from the ADNI database (adni.loni.usc.edu). ADNI was launched in 2003 as a public-private funding partnership and includes public funding by the National Institute on Aging, the National Institute of Biomedical Imaging and Bioengineering, and the Food and Drug Administration. The primary goal of ADNI has been to test a wide variety of measures to assess the progression of mild cognitive impairment and early Alzheimer's disease. The ADNI project is the result of efforts of many coinvestigators from a broad range of academic institutions and private corporations. Michael W. Weiner (VA Medical Center, and University of California-San Francisco) is the ADNI Principal Investigator. Subjects have been recruited from over 50 sites across the United States and Canada (for up-to-date information, see www.adni-info.org). 

The data in the following examples come from several modalities from the ADNI-GO/2 cohort. The data come from two sources available from the ADNI download site (http://adni.loni.usc.edu/): genome-wide data and the TADPOLE challenge data (https://tadpole.grand-challenge.org/) which contains a wide variety of data. Because the genetics data are used in every example, we provide all genetics preprocessing details here, and then describe any preprocessing for other data as we discuss specific examples.

For all examples in this paper we use a candidate set of single nucleotide polymorphisms (SNPs) extracted from the genome-wide data. We extracted only SNPs associated with the \textit{MAPT}, \textit{APP}, \textit{ApoE}, and \textit{TOMM40} genes because these genes are considered as candidate contributors to various AD pathologies: \textit{MAPT} because it is associated with tau proteins, AD pathology, or cognitive decline [@myers_h1c_2005; @trabzuni_mapt_2012; @desikan_genetic_2015; @cruchaga_rare_2012; @peterson_variants_2014], \textit{APP} because of its association with $\beta$-amyloid proteins [@cruchaga_rare_2012; @huang_apoe2_2017; @jonsson_mutation_2012], as well as \textit{ApoE} and \textit{TOMM40} because of their strong association with AD pathologies [@linnertz_cis-regulatory_2014; @roses_tomm40_2010-1; @bennet_pleiotropy_2010; @huang_apoe2_2017]. SNPs were processed as follows via @purcell2007plink with additional \texttt{R} code as necessary: minor allele frequency (MAF) $> 5\%$ and missingness for individuals and genotypes $\leq 10\%$. Because the SNPs are coded as categorical variables (i.e., for each genotype) we performed an additional level of preprocessing: genotypes $> 5\%$ because even with MAF $> 5\%$, it was possible that some genotypes (e.g., the heterozygote or minor homozygote) could still have very few occurrences. Therefore genotypes $\leq 5\%$ were combined with another genotype. In all cases the minor homozygote ('aa') fell below that threshold and was then combined with its respective heterozygote ('Aa'); thus some SNPs were effectively coded as the dominant model (i.e., the major homozygote vs. the presence of a minor allele). See Table  for an example of SNP data coding examples. From the ADNI-GO/2 cohort there were 791 available participants with 134 total SNPs across the four candidate genes. These 134 SNPs span 349 columns in disjunctive coding (see Table \ref{table:snps_models_disj}). Other data include diagnosis and demographics, some behavioral and cognitive instruments, and several types of brain-based measures. We discuss these additional data in further detail when we introduce these data.


```{r echo=F, results="asis", include=T, message=FALSE, warning=FALSE}

base.ex.snps <- c("Aa","aa","aa","AA","Aa","AA")
geno.model <- make_data_disjunctive(as.matrix(base.ex.snps))
  colnames(geno.model) <- gsub("1\\.","",colnames(geno.model))
  geno.model <- geno.model[,c("AA","Aa","aa")]
dom.model <- make_data_disjunctive(as.matrix( c("Aa+aa","Aa+aa","Aa+aa","AA","Aa+aa","AA") ))
  colnames(dom.model) <- gsub("1\\.","",colnames(dom.model))
  dom.model <- dom.model[,c("AA","Aa+aa")]
rec.model <- make_data_disjunctive(as.matrix( c("AA+Aa","aa","aa","AA+Aa","AA+Aa","AA+Aa") ))
  colnames(rec.model) <- gsub("1\\.","",colnames(rec.model)) 
  rec.model <- rec.model[,c("AA+Aa","aa")]

snp.tab <- cbind(base.ex.snps, geno.model, dom.model, rec.model)
  colnames(snp.tab)[1] <- "Genotype"
  rownames(snp.tab) <- paste("SUBJ", 1:nrow(snp.tab), sep=" ")

  kable( as.data.frame(snp.tab), "latex", caption="\\label{table:snps_models_disj} An example of a SNP with its genotypes for respective individuals and disjunctive coding for three types of genetic models: genotypic (three levels), dominant (two levels: major homozygote vs. presence of minor allele), and recessive (two levels: presence of major allele vs. minor homozygote)." , booktabs=T) %>% kable_styling(latex_options =c("hold_position")) %>%
  add_header_above(c(" ", "SNP" = 1, "Genotypic" = 3, "Dominant" = 2, "Recessive" = 2))
  
  
```


## Diagnosis and genotypes
\label{section:plscarda}

Our first example asks and answers the question: "which genotypes are associated with which diagnostic category?". In ADNI, diagnosis at baseline is a categorical variable that denotes which group each participant belongs to (at the first visit): control (CN; $N=$ `r table(TADPOLE.fin$DX_bl)["CN"]`), subjective memory complaints (SMC; $N=$  `r table(TADPOLE.fin$DX_bl)["SMC"]`), early mild cognitive impairment (EMCI; $N=$  `r table(TADPOLE.fin$DX_bl)["EMCI"]`), late mild cognitive impairment (LMCI; $N=$  `r table(TADPOLE.fin$DX_bl)["LMCI"]`), and Alzheimer's disease (AD; $N=$  `r table(TADPOLE.fin$DX_bl)["AD"]`). We present this first example analysis in two ways: akin to a standard regression problem a la Wold [@wold_soft_1975; @wold_collinearity_1984; @wold_principal_1987; cf. Eq. \ref{ols_equivalence}) and then again in the multivariate perspective of "projection onto latent structures" [@abdi_partial_2010-1].

```{r sample_descriptives, echo=F, results="asis", include=T, warning=F, message=F}

age.edu.n.tab <- TADPOLE.fin[,c("DX_bl","AGE","PTGENDER","PTEDUCAT")] %>% group_by(DX_bl) %>% summarise(N=n(), `age (mean)` = mean(AGE), `age (sd)` = sd(AGE), `edu (mean)` = mean(PTEDUCAT), `edu (sd)` = sd(PTEDUCAT))
sex.tab <- t(make_data_disjunctive(as.matrix(TADPOLE.fin[,"PTGENDER"]))) %*% make_data_disjunctive(as.matrix(TADPOLE.fin[,"DX_bl"]))
  rownames(sex.tab) <- gsub("1\\.","",rownames(sex.tab))
  colnames(sex.tab) <- gsub("1\\.","",colnames(sex.tab))

age.col <- apply(age.edu.n.tab[,c(3,4)],1,function(x){ round(x,digits=2) %>% paste(.,collapse=" (") %>% paste(.sep=")") %>% gsub(" )",")",.)})
edu.col <- apply(age.edu.n.tab[,c(5,6)],1,function(x){ round(x,digits=2) %>% paste(.,collapse=" (") %>% paste(.sep=")") %>% gsub(" )",")",.)})
mf.col <- apply(sex.tab,2,function(x){ paste(x,collapse=" (") } %>% paste(.,collapse=" (") %>% paste(.sep=")") %>% gsub(" )",")",.))
  names(mf.col) <- gsub("\\.","",names(mf.col))
  mf.col <- mf.col[age.edu.n.tab$DX_bl]
  
  desc.tab <- cbind(age.edu.n.tab$N, age.col, edu.col, mf.col)
    colnames(desc.tab) <- c("N","AGE mean (sd)","EDU mean (sd)","Males (Females)")
  rownames(desc.tab) <- age.edu.n.tab$DX_bl
  
kable(desc.tab, format = "latex", booktabs=T, caption="\\label{table:desctab} Descriptives and demographics for the sample. AD = Alzheimer's Disease, CN = control, EMCI = early mild cognitive impairment, LMCI = late mild cognitive impairment, SMC = subjective memory complaints.") %>%
  kable_styling(latex_options =c("hold_position")) 
  

```

```{r small_analyses, echo=F, include=T, warning=F, message=F}
  
  X <- make_data_disjunctive(as.matrix(TADPOLE.fin$DX_bl))
    rownames(X) <- rownames(TADPOLE.fin)
    colnames(X) <- gsub("1\\.","",colnames(X))
  Y <- genetic.nom
  
  ols.res <- plsca_reg(X,Y)
  
```

For this example we refer to diagnosis groups as the predictors (${\bf X}$) and the genotypic data as the responses (${\bf Y}$). Both data types are coded in disjunctive format (see Tables \ref{table:disj} and \ref{table:snps_models_disj}). Because there are five columns (groups) in ${\bf X}$, PLS-CA-R produces only four latent variables (a.k.a. components). Table \ref{table:r2ex1} presents the cumulative explained variance for both ${\bf X}$ and ${\bf Y}$ and shows that groups explain only a small amount of genotypic variance: $R^2=$ `r round(sum(ols.res$r2_y),digits=4)`.

```{r echo=F,results="asis"}
ols.r2.table <- cbind(cumsum(ols.res$r2_x),  cumsum(ols.res$r2_y))
colnames(ols.r2.table) <- c("X (groups) R-squared cumulative","Y (genotypes) R-squared cumulative")
rownames(ols.r2.table) <- paste0("Latent variable ",1:length(ols.res$betas))

kable(ols.r2.table,digits = 4,
      format="latex",
      caption=paste("\\label{table:r2ex1} The R-squared values over the four latent variables for both groups and genotypes. The full variance of groups is explained over the four latent variables. The groups explained ", round(sum(ols.res$r2_y)*100,digits=2), "\\% of the genotypes.",sep=""),
      booktabs=T) %>%
  kable_styling(latex_options =c("hold_position")) # %>%
  # add_header_above(c(" ", "Original coding" = 3, "Disjunctive and pseudo-disjunctive coding" = 6))


```



In a simple regression-like framework we can compute the variance contributed by genotypes or group (i.e., levels of variables) or variance contributed by entire variables (in this example: SNPs). First we compute the contributions to the variance of the genotypes as the sum of the squared loadings for each item: $[(\widetilde{\bf V} \odot \widetilde{\bf V}){\bf 1}] \times C^{-1}$, where ${\bf 1}$ is a conformable vector of ones. Total contribution takes values between 0 and 1 and describe the proportion of variance for each genotype. Because the contributions are squared loadings, they are additive and so we can compute the contributions for a SNP. A simple criterion to identify genotypes or SNPs that contribute to the model is to identify which genotype or SNP contributes more variance than expected, which is one divided by the total number of original variables (i.e., SNPs). This criterion can be applied on the whole or component-wise. We show the genotypes and SNPs with above expected variance for the whole model (i.e., high contributing variables a regression framework) in Figure \ref{fig:leverages_ex1}. 


```{r echo=F, fig.cap="\\label{fig:leverages_ex1} Regression approach to prediction of genotypes from groups. Contributions across all components for genotypes (A; top) and the SNPs (B; bottom) computed as the summation of genotypes within a SNP. The horizontal line shows the expected variance and we only highlight genotypes (A; top) or SNPs (B; bottom) greater than the expected variance. Some of the highest contributing genotypes (e.g., AA and AG genotypes for rs769449) or SNPs (e.g.,  rs769449 and rs20756560) come from the APOE and TOMM40 genes.",fig.height=8,fig.width=6, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center",fig.pos = "!hbtp"}

par.opts <- par(mfrow=c(2,1))
var.cutoff <- 1/ncol(genetic.data)
genotype.leverages <- rowSums(ols.res$v^2)/length(ols.res$betas) # normed to 1

snp.leverages <- rowSums(t(genetic.nom.design) %*% (ols.res$v^2))/length(ols.res$betas) # normed to 1
  names(snp.leverages) <- gsub("1\\.","",names(snp.leverages))

  
high.leverage.genotypes <- which(genotype.leverages > var.cutoff)
high.leverage.genotypes.pos <- rep(3,length(high.leverage.genotypes))
high.leverage.genotypes.pos <- ifelse(high.leverage.genotypes < 100, 4, high.leverage.genotypes.pos)
high.leverage.genotypes.pos <- ifelse(high.leverage.genotypes > 100 & high.leverage.genotypes < 135 | high.leverage.genotypes > 250, 2, high.leverage.genotypes.pos)

high.leverage.snps <- which(snp.leverages > var.cutoff)
high.leverage.snps.pos <- rep(3,length(high.leverage.snps))
high.leverage.snps.pos <- ifelse(high.leverage.snps < 40, 4, high.leverage.snps.pos)
high.leverage.snps.pos <- ifelse(high.leverage.snps > 100, 2, high.leverage.snps.pos)

## these plots should have the same limits.
plot(genotype.leverages,pch=20,ylim=c(0,max(snp.leverages)*1.1),col=ifelse(genotype.leverages > var.cutoff,"mediumorchid4","grey90"),ylab="Genotype contributions (leverages)",xlab="")
abline(h=var.cutoff,col="black",lwd=2,lty=2)
text(cbind(high.leverage.genotypes,genotype.leverages[high.leverage.genotypes]),labels = names(high.leverage.genotypes), col="mediumorchid4",pos=high.leverage.genotypes.pos,cex = .65)
mtext(paste0("(A)"), side = 3, adj = 0,line=0.75,cex=1.5)

## total variance for SNPs
plot(snp.leverages,pch=20,ylim=c(0,max(snp.leverages)*1.1),col=ifelse(snp.leverages > var.cutoff,"mediumorchid4","grey90"),ylab="SNP contributions (leverages)",xlab="")
abline(h=var.cutoff,col="black",lwd=2,lty=2)
text(cbind(high.leverage.snps,snp.leverages[high.leverage.snps]),labels = names(high.leverage.snps), col="mediumorchid4",pos=high.leverage.snps.pos,cex = .65)
mtext(paste0("(B)"), side = 3, adj = 0,line=0.75,cex=1.5)

par(par.opts)


```

Though PLS-R was initally developed as a regression approach---especially to handle collinear predictors [see explanations in @wold_collinearity_1984]---it is far more common to use PLS to find latent structures (i.e., components or latent variables) [@abdi_partial_2010-1]. From here on we show the latent variable scores (observations) and component scores (variables) for the first two latent variables/components in Figure \ref{fig:contributions_ex1}. The first latent variable scores (Fig. \ref{fig:contributions_ex1}a) shows a gradient from the control (CN) group through to the Alzheimer's Disease (AD) groups (CN to SMC to EMCI to LMCI to AD). The second latent variable shows a dissociation of the EMCI group from all other groups (Fig. \ref{fig:contributions_ex1}b). Figure \ref{fig:contributions_ex1}c and d show the component scores for the variables. Genotypes on the left side of first latent variable (horizontal axis in Figs. \ref{fig:contributions_ex1}c and d) are more associated with CN and SMC than the other groups, whereas genotypes on the right side are more associated with AD and LMCI than with the other groups. Through the latent structures approach we can more clearly see the relationships between groups and genotypes. Because we treat the data categorically and code for genotypes, we can identify the specific genotypes that contribute to these effects. For example the 'AA' genotype of rs769449 and the 'GG' genotype of rs2075650 are more associated with AD and LMCI than with the other groups. In contrast, the 'TT' genotype of rs405697 and the 'TT' genotype rs439401 are more associated with the CN group than other groups (and thus could suggest potential protective effects).


```{r echo=F,results="asis", fig.cap="\\label{fig:contributions_ex1} Latent variable projection approach to prediction of genotypes from groups. (A) and (B) show the latent variable scores for latent variables (LVs; components) one and two, respectively; (C) shows the component scores of the groups, and (D) shows the component scores of the genotypes. In (D) we highlight genotypes with above expected contribution to Latent Variable (Component) 1 in purple and make all other genotypes gray.", fig.height=8, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center",fig.pos = "!hbtp"}
  
  genotype.contributions_12 <- (ols.res$v[,1:2]^2) > var.cutoff
  fj.cols <- rep(prettyGraphs::add.alpha("grey80",.6),nrow(ols.res$fj))
  fj.cols <- ifelse(rowSums(genotype.contributions_12)==2,prettyGraphs::add.alpha("goldenrod",.8),fj.cols)
  fj.cols <- ifelse(genotype.contributions_12[,1]==T & genotype.contributions_12[,2]==F,prettyGraphs::add.alpha("mediumorchid4",.7),fj.cols)
  fj.cex <- ifelse(rowSums(genotype.contributions_12)==0,.5,1.25)
  
  
  par.opts <- par(mfrow=c(2,2))
  #sp.latentvar_plot(ols.res, display_names = F, bg=prettyGraphs::add.alpha("mediumorchid4",.6),col=prettyGraphs::add.alpha("grey80",.6),pch=21)
  sp.latentvar_plot(ols.res, display_names = F, bg=prettyGraphs::add.alpha(ind.cols,.5),col=prettyGraphs::add.alpha("grey80",.5),pch=21)
  svd.line(cbind(ols.res$lx[,1],ols.res$ly[,1]),col=prettyGraphs::add.alpha("black",.6),lwd=2)
  mtext(paste0("(A)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  #sp.latentvar_plot(ols.res, axis = 2, display_names = F, bg=prettyGraphs::add.alpha("mediumorchid4",.6),col=prettyGraphs::add.alpha("grey80",.6),pch=21)
  sp.latentvar_plot(ols.res, axis = 2, display_names = F, bg=prettyGraphs::add.alpha(ind.cols,.5), col=prettyGraphs::add.alpha("grey80",.5),pch=21)
  svd.line(cbind(ols.res$lx[,2],ols.res$ly[,2]),col=prettyGraphs::add.alpha("black",.6),lwd=2)
  mtext(paste0("(B)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  # ours::component_plot(ols.res$fi %*% diag(1/ols.res$d),col=grp.cols,pos=c(3,1,3,2,1),cex=2,text.cex = 1)
  ours::component_plot(ols.res$fi,col=grp.cols,pos=c(3,1,3,2,1),cex=2,text.cex = 1)
  ## here I should provide color coding for items above expected for the whole model and just for either of the visualized two.
  # fj.a.copy <- ols.res$fj %*% diag(1/ols.res$d)
  fj.a.copy <- ols.res$fj
  rownames(fj.a.copy) <- colnames(Y)
  rownames(fj.a.copy) <- ifelse(genotype.contributions_12[,1],rownames(fj.a.copy),"")
  mtext(paste0("(C)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  #ep.ours::component_plot(fj.a.copy,display_names = T,pch=21,col=prettyGraphs::add.alpha("black",.6),bg=fj.cols, cex=fj.cex, text.cex = .5)
  ours::component_plot(fj.a.copy,display_names = T,pch=20,col=fj.cols, cex=fj.cex, text.cex = .5)
  mtext(paste0("(D)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  par(par.opts)
  
```


```{r echo=F, results="asis", fig.height=8, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center", fig.cap="\\label{fig:discriminant_ex1} Discriminant PLS-CA-R. (A) shows the component scores for the group on Latent Variables (LV) 1 and 2 (horizontal and vertical respectively), (B) shows the latent variable scores for the genotype ('LY') LV scores for LVs 1 and 2, colored by \\textit{a priori} group association, (C) shows the latent variable scores for the genotype ('LY') LV scores for LVs 1 and 2, colored by \\textit{assigned} group association (i.e., nearest group assignment across all LVs), and (D) shows correct vs. incorrect assignment in black and gray, respectively.",fig.pos = "!hbtp", warning=F, message=F}


  disc1.scores <- ols.res$fi
  Y_ca_preproc <- ca_preproc(Y)
  disc1.ly <- (diag(1/sqrt(Y_ca_preproc$m)) %*% ols.res$ly)  
  # disc1.ly <- ols.res$ly * sqrt(nrow(Y))

  disc1.lims <- c(-max(abs(rbind(disc1.scores,disc1.ly)[,1:2])),max(abs(rbind(disc1.scores,disc1.ly)[,1:2])))*1.2
  
  DESIGN <- make_data_disjunctive(as.matrix(TADPOLE.fin$DX_bl))
    colnames(DESIGN) <- gsub("1\\.","",colnames(DESIGN))
  fii2fi.res <- TExPosition::fii2fi(DESIGN,disc1.ly,disc1.scores)
  assigned.grps <- colnames(fii2fi.res$confusion)[apply(fii2fi.res$assignments,1,function(x){which(x==1)})]
  
  assigned.cols <- plyr::mapvalues(assigned.grps,from=names(grp.cols),to=grp.cols)
  names(assigned.cols) <- rownames(fii2fi.res$assignments)
  
  conf.tab <- fii2fi.res$confusion
  colnames(conf.tab) <- gsub("\\.","",colnames(conf.tab))
  
  correct.incorrect <- apply(DESIGN + fii2fi.res$assignments,1,function(x){any(x==2)})
  correct.incorrect.cols <- ifelse(correct.incorrect,"black","grey80")
  
  par.opts <- par(mfrow=c(2,2))
  
  ours::component_plot(disc1.scores, col=grp.cols,xlim = disc1.lims,ylim=disc1.lims,main="Groups",pos=c(2,1,3,4,2),cex=2,text.cex = 1)
  mtext(paste0("(A)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  ours::component_plot(disc1.ly, display_names = F,col=prettyGraphs::add.alpha(ind.cols,.5),xlim = disc1.lims,ylim=disc1.lims,main="Actual",xlab="LY1",ylab="LY2")
  mtext(paste0("(B)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  ours::component_plot(disc1.ly, display_names = F,col=prettyGraphs::add.alpha(assigned.cols,.5),xlim = disc1.lims,ylim=disc1.lims,main="Assigned",xlab="LY1",ylab="LY2")
  mtext(paste0("(C)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  ours::component_plot(disc1.ly, display_names = F,col=prettyGraphs::add.alpha(correct.incorrect.cols,.5),xlim = disc1.lims,ylim=disc1.lims,main="Correct vs. Incorrect",xlab="LY1",ylab="LY2")
  mtext(paste0("(D)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  par(par.opts)

```


This group-based analysis is also a discriminant analysis because it maximally separates groups. Thus we can classify observations by assigning them to the closest group. To correctly project observations onto the latent variables we compute ${\bf M}_{\bf Y}^{-\frac{1}{2}}{\mathbf L}_{\mathbf Y} = [{\bf O}_{\bf Y} \oslash ({\bf m}_{\bf Y}{\bf 1}^T)]{\bf F}_{K}\boldsymbol{\Delta}^{-1}$ where $1$ is a $1 \times K$ vector of ones where ${\bf O}_{\bf Y} \oslash ({\bf m}_{\bf Y}{\bf 1}^T)$ are "row profiles" of ${\bf Y}$ (i.e., each element of ${\bf Y}$ divided by its respective row sum). Observations from ${\bf M}_{\bf Y}^{-\frac{1}{2}}{\mathbf L}_{\mathbf Y}$ are then assigned to the closest group in ${\mathbf F}_{J}$, either for per component, across a subset of components, or all components. For this example we use the full set (four) of components. The assigned groups can then be compared to the *a priori* groups to compute a classification accuracy. Figure \ref{fig:discriminant_ex1} shows the results of the discriminant analysis but only visualized on the first two components. Figures \ref{fig:discriminant_ex1}a and b respectively show the scores for ${\mathbf F}_{J}$ and ${\bf M}_{\bf Y}^{-\frac{1}{2}}{\mathbf L}_{\mathbf Y}$. Figure \ref{fig:discriminant_ex1}c shows the assignment of observations to their closest group. Figure \ref{fig:discriminant_ex1}d visualizes the accuracy of the assignment, where observations in black are correct assignments (gray are incorrect assignments). The total classification accuracy `r round((sum(diag(conf.tab)) / sum(conf.tab))*100,digits=2)`% (where chance accuracy was `r round(sum((colSums(DESIGN) / sum(DESIGN))^2)*100,digits=2)`%). Finally, typical PLS-R discriminant analyses are applied in scenarios where a small set of, or even a single, (typically) categorical responses are predicted from many predictors [@perez-enciso_prediction_2003]. However, such an approach appears to be "over optimistic" in its prediction and classification [@rodriguez-perez_overoptimism_2018], which is why we present discriminant PLS-CA-R more akin to a typical regression problem (i.e., here a single predictor with multiple responses).


```{r echo=F,results="asis"}
kable(conf.tab[c("CN","SMC","EMCI","LMCI","AD"),c("CN","SMC","EMCI","LMCI","AD")],format="latex",caption="\\label{table:assign_ex1} The \\textit{a priori} (rows) vs. assigned (columns) accuracies for the discriminant analysis. AD = Alzheimer's Disease, CN = control, EMCI = early mild cognitive impairment, LMCI = late mild cognitive impairment, SMC = subjective memory complaints.", booktabs=T) %>%
  kable_styling(latex_options =c("hold_position")) %>%
  add_header_above(c(" ", "Assigned" = 5), italic = T)
```


## Mixed data and residualization
\label{section:mixed}

Our second example illustrates the prediction of genotypes from brain and behavioral variables: (1) three behavioral/clinical scales: Montreal Cognitive Assessment (MoCA) [@nasreddine_montreal_2005], Clinical Dementia Rating-Sum of Boxes (CDRSB) [@morris1993clinical], and Alzheimer's Disease Assessment Scale (ADAS13) [@skinner_alzheimers_2012], (2) volumetric brain measures in $\textrm{mm}^3$: hippocampus (HIPPO), ventricles (VENT), and whole brain (WB), and (3) global estimates of brain function via PET scans: average FDG (for cerebral blood flow; metabolism) in angular, temporal, and posterior cingulate and average AV45 (A$\beta$ tracer) standard uptake value ratio (SUVR) in frontal, anterior cingulate, precuneus, and parietal cortex relative to the cerebellum. This example higlights two features of PLS-CA-R: (1) the ability to accomodate mixed data types (continuous, ordinal, and categorical) and (2) as a way to residualize (orthogonalize; cf. Eq. \ref{eq:Yresid}) with respect to known or assumed covariates.

Here, the predictors encompass a variety of data types: all of the brain markers (volumetric MRI estimates, functional PET estimates) and the ADAS13 are quantitative variables, whereas the MoCA and the CDRSB can be considered as ordinal data. Continuous and ordinal data types can be coded into what is called thermometer [@beaton2018generalization], fuzzy, or "bipolar" coding (because it has two poles) [@greenacrefuzzy]; an idea initially propsosed by Escofier for continuous data [@escofier_traitement_1979]. The "Escofier transform" allows continuous data to be analyzed by CA and produces the exact same results as PCA [@escofier_traitement_1979]. The same principles can be applied to ordinal data as well [@beaton2018generalization]. Continuous and ordinal data can be transformed into a "pseudo-disjunctive" format that behaves exactly like complete disjunctive data (see Table \ref{table:disj}) but preserves the values (as opposed to binning, or dichotomizing). Here, we refer to the transform for continuous data as the "Escofier transform" or "Escofier coding" [@beaton_partial_2016] and the transform for ordinal data as the "thermometer transform" or "thermometer coding". Because continuous, ordinal, and categorical data can all be transformed into a disjunctive-like format, they can all be analyzed with PLS-CA-R.

The next example identifies the relationship between brain and behavioral markers of AD and genetics. We use the brain and behavioral data as the predictors and the genetics as responses. However, both data sets have their own covariates (some of which are confounds): age, sex, and education influence the behavioral and brain data, where sex, and population origins influence the genotypic variables. For genetic covariates, we use proxies of population origins: self-identified race and ethnicity categories. Both sets of covariates are miixtures of data types (e.g., sex is categorical, age is generally continuous). So, in this example, we illustrate the mixed analysis in two ways---unadjusted and then adjusted for these covariates. First we show the effects of the covariates on the separate data sets, and then compare and contrast adjusted vs. unadjusted analyes. For these analyses, the volumetric brain data were also normalized (divided by) by intracranial volume prior to these analyses to create proportions of total volume for each brain structure.

```{r echo=F, include=F, warning=F, message=F}


    ## could add ADAS_11 and ADAS_13
  cont.vals.doubled <- escofier_coding( cbind(TADPOLE.fin[,c("FDG_bl","AV45_bl","ADAS13_bl")],structural.norm),scale=T)
    
    ## could add MOCA
  ord.vals.doubled <- thermometer_coding(TADPOLE.fin[,c("MOCA_bl","CDRSB_bl")], mins = c(0,0), maxs = c(30,9))
  

  nom.vals <- make_data_disjunctive(as.matrix(TADPOLE.fin[,c("DX_bl")]))
  colnames(nom.vals) <- gsub("1\\.","",colnames(nom.vals))
  rownames(nom.vals) <- rownames(TADPOLE.fin)
  
  pre.mixed.X <- as.matrix(cbind(ord.vals.doubled,cont.vals.doubled))
    rownames(pre.mixed.X) <- rownames(TADPOLE.fin)
    pre.mixed.X <- apply(pre.mixed.X,2,function(x){ x[which(is.na(x))] <- mean(x,na.rm=T);x })
    colnames(pre.mixed.X) <- gsub("_bl","",colnames(pre.mixed.X))
  
    
    #### NEED TO COME BACK TO THIS.
  age.doubled <- escofier_coding(as.matrix(TADPOLE.fin$AGE),scale=T)
  colnames(age.doubled) <- c('AGE-','AGE+')
  edu.thermometer <- thermometer_coding(as.matrix(TADPOLE.fin$PTEDUCAT))
  colnames(edu.thermometer) <- c('EDU-','EDU+')
  beh.brain.confounds <- cbind(make_data_disjunctive(as.matrix(TADPOLE.fin[,c("PTGENDER")])),age.doubled,edu.thermometer)
  colnames(beh.brain.confounds) <- gsub("1\\.","",colnames(beh.brain.confounds))
  rownames(beh.brain.confounds) <- rownames(TADPOLE.fin)
  
  
  regress.beh.brain.pls <- plsca_reg(beh.brain.confounds,pre.mixed.X)

  gene.confounds <- as.matrix(TADPOLE.fin[,c("PTETHCAT","PTRACCAT","PTGENDER")])
  gene.confounds <- gsub("Unknown",NA,gene.confounds)
  gene.confounds.nom <- make_data_disjunctive(gene.confounds)
  colnames(gene.confounds.nom) <- gsub("PTGENDER","SEX",gsub("PTETHCAT","ETH",gsub("PTRACCAT","RACE",colnames(gene.confounds.nom))))
  
  regress.genes.pls <- plsca_reg(gene.confounds.nom,genetic.nom)
  
  
  ## regressed data.
  mixed.X.resids <- regress.beh.brain.pls$Y_residual
  genetic.resids <- regress.genes.pls$Y_residual
  
  
  plsrca.res <- plsca_reg(pre.mixed.X,genetic.nom)
  plsrca.res_regressed <- plsca_reg(mixed.X.resids,genetic.resids) 
  
  
  beh.brain.confounds.colors <- rep(prettyGraphs::add.alpha("grey60",.6),ncol(beh.brain.confounds))
  names(beh.brain.confounds.colors) <- colnames(beh.brain.confounds)
  beh.brain.confounds.colors[colnames(beh.brain.confounds)[grep("\\+",colnames(beh.brain.confounds))]] <- "mediumorchid4"
  beh.brain.confounds.colors["Male"] <- "aquamarine3"
  beh.brain.confounds.colors["Female"] <- "coral3"
  
  mixed.X.colors <- rep(prettyGraphs::add.alpha("grey60",.6),ncol(pre.mixed.X))
  names(mixed.X.colors) <- colnames(pre.mixed.X)
  mixed.X.colors[colnames(pre.mixed.X)[grep("\\+",colnames(pre.mixed.X))]] <- "mediumorchid4"
  
```

First we show the PLS-CA-R between each data set and their respective covariates The main effects of age, sex, and education explained `r round(sum(regress.beh.brain.pls$r2_y)*100,digits=2)`% of the variance of the behavioral and brain data, where the main effects of sex, race, and ethnicity explained `r round(sum(regress.genes.pls$r2_y)*100,digits=2)`% of the variance of the genotypic data. The first two components of each analysis are shown in Figure \ref{fig:confound_predictors_ex2}. In the brain and behavioral data, age explains a substantial amount of variance for Component 1. In the genotypic analysis, self-identified race and ethnicity are the primary overall effects, where the first two components are explained by those that identify as black or African-American (Component 1) vs. those that identify as Asian, Native, Hawaiian, and/or Latino/Hispanic (Component 2). Both data sets were reconstituted (i.e., ${\mathbf Y}_{\epsilon}$ from Eq. \ref{eq:Yresid}) from their residuals. 

Next we performed two analyses with the same goal: to understand the relationship between genetics and behavioral and brain markers of AD. In the unadjusted analysis, the brain and behavioral data explained `r round(sum(plsrca.res$r2_y)*100,digits=2)`% of variance in the genotypic data, whereas in the adjusted analysis, the brain and behavioral data explained `r round(sum(plsrca.res_regressed$r2_y)*100,digits=2)`% of variance in the genotypic data. The first two components of the PLS-CA-R results can be seen in Figure \ref{fig:confound_predictors_ex2}.

```{r echo=F, include=T, fig.height=8, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center", fig.cap="\\label{fig:confound_predictors_ex2} PLS-CA-R used as a way to residualize (orthogonalize) data. The top figures (A) and (B) show prediction of the brain and behavior markers from age, sex, and education. Gray items are one side (lower end) of the \"bipolar\" or pseudo-disjunctive variables. The bottom figures (C) and (D) show the prediction of genotypes from sex, race, and ethnicity.",fig.pos = "!hbtp"}
 
  par.opts <- par(mfrow=c(2,2))

  # ours::component_plot(regress.beh.brain.pls$fi %*% diag(1/regress.beh.brain.pls$d),cex=2,text.cex = .75,pch=20,display_names = T, col=beh.brain.confounds.colors)
ours::component_plot(regress.beh.brain.pls$fi,cex=2,text.cex = .75,pch=20,display_names = T, col=beh.brain.confounds.colors)
  mtext(paste0("(A)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  # ours::component_plot(regress.beh.brain.pls$fj %*% diag(1/regress.beh.brain.pls$d),cex=2,text.cex = .75,pch=20,display_names = T, col=mixed.X.colors)
  ours::component_plot(regress.beh.brain.pls$fj,cex=2,text.cex = .75,pch=20,display_names = T, col=mixed.X.colors)
  mtext(paste0("(B)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  # ours::component_plot(regress.genes.pls$fi %*% diag(1/regress.genes.pls$d),cex=2,text.cex = .75,pch=20,display_names = T)
  ours::component_plot(regress.genes.pls$fi,cex=2,text.cex = .75,pch=20,display_names = T)
  mtext(paste0("(C)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  # ours::component_plot(regress.genes.pls$fj %*% diag(1/regress.genes.pls$d),cex=1,text.cex = .5,pch=20,display_names = T)
  ours::component_plot(regress.genes.pls$fj,cex=1,text.cex = .5,pch=20,display_names = T)
  mtext(paste0("(D)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  par(par.opts)

  
```

In the unadjusted analysis (Figures \ref{fig:confound_predictors_ex2}a and c) vs. the adjusted analysis (Figures \ref{fig:confound_predictors_ex2}b and d), we can see some similarities and differences, especially with respect to the behavioral and brain data. AV45 shows little change after residualization, and generally explains a substantial amount of variance as it contributes highly to the first two components in both analyses. The effects of the structural data---especially the hippocampus---are dampened after adjustment (see Figures \ref{fig:confound_predictors_ex2}a vs b), where the effects of FDG and CDRSB are now (relatively) increased (see Figures \ref{fig:confound_predictors_ex2}a vs b). On the subject level, the differences are small but noticeable, especially for distinguishing between groups (see Figure \ref{fig:lv_compare_ex2}). One important effect is that on a spectrum from CON to AD, we can see that the residualization has a larger impact on the CON side, where the AD side remains somewhat homgeneous (see Figure \ref{fig:lv_compare_ex2}c) for the brain and behavioral variables. With respect to the genotypic LV, there is much less of an effect (see Figure \ref{fig:lv_compare_ex2}d), wherein the observations appear relatively unchanged. However, both pre- (horizontal axis; Figure \ref{fig:lv_compare_ex2}d) and post- (vertical axis; Figure \ref{fig:lv_compare_ex2}d) residualization shows that there are individuals with unique genotypic patterns that remain unaffected by the residualization process (i.e., those at the tails). 

From this point forward we emphasize the results from the adjusted analyses because they are more realistic in terms of how analyses are performed. For this we refer to Figure \ref{fig:lv_compare_ex2}b---which shows the latent variable scores for the observations and the averages of those scores for the groups---and Figures \ref{fig:original_residualized_ex2}b and \ref{fig:original_residualized_ex2}d---which show, respectively, the component scores for the brain and behavioral markers and the component scores for the genotypes. The first latent variable (Fig. \ref{fig:lv_compare_ex2}b) shows a gradient from control (CON) on the left to Alzheimer's Disease (AD) on the right. Brain and behavioral variables on the right side of the first component (horizontal axis in Fig. \ref{fig:original_residualized_ex2}b) are more associated with genotypes on the right side (Fig. \ref{fig:original_residualized_ex2}d), where brain and behavioral variables on the left side of the horizontal axis are more associated with genotypes on the left side. In particular, the AA genotype of rs769449, GG genotype of rs2075650, GG genotype of rs4420638, and AA genotype of rs157582 (amongst others) are related to increased AV45 (AV45+), decreased FDG (FDG-), and increased ADAS13 scores (ADAS13+), whereas the TT genotype of rs405697, GG genotype of rs157580, and TC+TT genotypes of rs7412 (amongst others) are more associated with control or possibly protective effects (i.e., decreased AV4, increased FDG, and decreased ADAS13 scores).


```{r echo=F,results="asis",fig.height=8, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center", fig.cap="\\label{fig:original_residualized_ex2} PLS-CA-R to predict genotypes from brain and behavioral markers on the original and residualized data shown on the first two latent variables (components). The top figures (A) and (B) show the component scores for the brain and behavioral markers for the original and residualized data, respectively, and the bottom figures (C) and (D) show the component scores for the genotypes for the original and residualized data, respectively.",fig.pos = "!hbtp"}

  par.opts <- par(mfrow=c(2,2))
  # ours::component_plot(plsrca.res$fi %*% diag(1/plsrca.res$d),cex=2,pch=20,display_names = F,main="Original Predictors\n(brain & behavior)", col=mixed.X.colors)
ours::component_plot(plsrca.res$fi,cex=2,pch=20, display_names = F,main="Original Predictors\n(brain & behavior)", col=mixed.X.colors)
  thigmophobe.labels(plsrca.res$fi[,1], plsrca.res$fi[,2],labels = rownames(plsrca.res$fi), col=mixed.X.colors, cex=.75)
  mtext(paste0("(A)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  # ours::component_plot(plsrca.res_regressed$fi %*% diag(1/plsrca.res_regressed$d),cex=2,pch=20,display_names = F,main="Residualized Predictors\n(brain & behavior)",col=mixed.X.colors)
  ours::component_plot(plsrca.res_regressed$fi,cex=2,pch=20,display_names = F,main="Residualized Predictors\n(brain & behavior)",col=mixed.X.colors)
  thigmophobe.labels(plsrca.res_regressed$fi[,1],plsrca.res_regressed$fi[,2],labels = rownames(plsrca.res_regressed$fi), col=mixed.X.colors, cex=.75)
  mtext(paste0("(B)"), side = 3, adj = -.25,line=1.5,cex=1.5)
    
  # ours::component_plot(plsrca.res$fj %*% diag(1/plsrca.res$d),display_names = T,pch=20,cex=1, text.cex = .5,main="Original Responses\n(genotypes)")
  ours::component_plot(plsrca.res$fj,display_names = T,pch=20,cex=1, text.cex = .5,main="Original Responses\n(genotypes)")
  mtext(paste0("(C)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  # ours::component_plot(plsrca.res_regressed$fj %*% diag(1/plsrca.res_regressed$d),display_names = T,pch=20,cex=1, text.cex = .5,main="Residualized Responses\n(genotypes)")
  ours::component_plot(plsrca.res_regressed$fj,display_names = T,pch=20,cex=1, text.cex = .5,main="Residualized Responses\n(genotypes)")
  mtext(paste0("(D)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  par(par.opts)
  
```



```{r echo=F,results="asis",fig.height=8, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center", fig.cap="\\label{fig:lv_compare_ex2} Latent variable scores (observations) for the first latent variable. The top figures (A) and (B) show the projection of the latent variable scores from each set: LX are the brain and behavioral markers, where as LY are the genotypes, for the original and residualized, respectively. The bottom figures (C) and (D) show the the original and residualized scores for the first latent variable compared to one another for each set: the brain and behavioral markers (LX) and the genotypes (LY), respectively.",fig.pos = "!hbtp"}


  par.opts <- par(mfrow=c(2,2))

  sp.latentvar_plot(plsrca.res, display_names = F, bg=prettyGraphs::add.alpha(ind.cols,.5),col=prettyGraphs::add.alpha("grey80",.5),pch=21,main="Original LV1")
  mtext(paste0("(A)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  sp.latentvar_plot(plsrca.res_regressed, display_names = F, bg=prettyGraphs::add.alpha(ind.cols,.5),col=prettyGraphs::add.alpha("grey80",.5),pch=21,main="Residualized LV1")
  mtext(paste0("(B)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  plot(plsrca.res$lx[,1],plsrca.res_regressed$lx[,1],bg=prettyGraphs::add.alpha(ind.cols,.5), col=prettyGraphs::add.alpha("grey80",.5),pch=21,xlab="Original LX 1",ylab="Residualized LX 1")
  legend("topleft",legend=names(grp.cols[c("CN","SMC","EMCI","LMCI","AD")]),pch=18,col=grp.cols[c("CN","SMC","EMCI","LMCI","AD")],text.col = grp.cols[c("CN","SMC","EMCI","LMCI","AD")], cex=.75)
  mtext(paste0("(C)"), side = 3, adj = -.25,line=1.5,cex=1.5)
  
  plot(plsrca.res$ly[,1],plsrca.res_regressed$ly[,1],bg=prettyGraphs::add.alpha(ind.cols,.5), col=prettyGraphs::add.alpha("grey80",.5),pch=21,xlab="Original LY 1",ylab="Residualized LY 1")
  mtext(paste0("(D)"), side = 3, adj = -.25,line=1.5,cex=1.5)
    
  par(par.opts)
  
```

## SUVR and genotypes
\label{section:big}



```{r echo=F, include=F, warning=FALSE, message=FALSE}

  CTX.uptake <- TADPOLE.fin[,grep("CTX",colnames(TADPOLE.fin))]
  colnames(CTX.uptake) <- gsub("_UCBERKELEYAV45_10_17_16","",gsub("CTX_","",colnames(CTX.uptake)))
  
  drop.rows <- which(rowSums(is.na(CTX.uptake))==70)
  drop.cols <- grep("UNKNOWN",colnames(CTX.uptake))
  CTX.uptake_drop <- CTX.uptake[-c(drop.rows),-c(drop.cols)]
  CTX.uptake_drop <- apply(CTX.uptake_drop,2,function(x){ x[which(is.na(x))] <- mean(x,na.rm=T); x })
  
  genetic.nom_drop <- genetic.nom[rownames(CTX.uptake_drop),]


  
  age.doubled <- escofier_coding(as.matrix(TADPOLE.fin$AGE[-c(drop.rows)]),scale=T)
  colnames(age.doubled) <- c('AGE-','AGE+')
  edu.thermometer <- thermometer_coding(as.matrix(TADPOLE.fin$PTEDUCAT[-c(drop.rows)]))
  colnames(edu.thermometer) <- c('EDU-','EDU+')
  beh.brain.confounds <- cbind(make_data_disjunctive(as.matrix(TADPOLE.fin[-c(drop.rows),c("PTGENDER")])),age.doubled,edu.thermometer)
  colnames(beh.brain.confounds) <- gsub("\\.","",colnames(beh.brain.confounds))
  rownames(beh.brain.confounds) <- rownames(TADPOLE.fin)[-c(drop.rows)]
  
    ## this puts it back into its oritingal space, but we can't guarantee that that will be orthgonal
   regress.uptake.pls <- plsca_reg(beh.brain.confounds,CTX.uptake_drop)
  
  gene.confounds <- as.matrix(TADPOLE.fin[rownames(genetic.nom_drop),c("PTETHCAT","PTRACCAT","PTGENDER")])
  gene.confounds <- gsub("Unknown",NA,gene.confounds)
  gene.confounds.nom <- make_data_disjunctive(gene.confounds)
  colnames(gene.confounds.nom) <- gsub("PTGENDER","SEX",gsub("PTETHCAT","ETH",gsub("PTRACCAT","RACE",colnames(gene.confounds.nom))))
  
  regress.genes.drop.pls <- plsca_reg(gene.confounds.nom,genetic.nom_drop)
  
  
  big.plsrca.res <- plsca_reg(regress.uptake.pls$Y_residual,regress.genes.drop.pls$Y_residual)
   
```

In this final example we use all of the features of PLS-CA-R: mixed data types within and between data sets, each with covariates (and thus require residualization). The goal of this example is to predict genotypes from $\beta-$amyloid burden ("AV45 uptake") across regions of the cortex. In this case, because the AV45 uptake data are are strictly non-negative, we effectively treat these data as counts; that is, we would normally apply CA directly to this one data table. Of course, this is only one possible way to handle such data. It is possible to treat these data as row-wise proportions (i.e., percentage of total uptake per region within each subject) or even as continuous data. Ultimately, it is up to analysts and experts to decide how to best treat such data, and how it fits into the analysis framework. 


Because not all subjects have complete AV45 and genotypic data, the sample for this example is slightly smaller: $N=$ `r nrow(regress.uptake.pls$Y_residual)`. Ethnicity, race, and sex (all categorical) explains `r round(sum(regress.genes.drop.pls$r2_y)*100,digits=2)`% of the variance in the genotypic data where age (numeric), education (ordinal), and sex (categorical) explains `r round(sum(regress.uptake.pls$r2_y)*100,digits=2)`% of the variance in the in the AV45 uptake data. Overall, AV45 brain data explains `r round(sum(big.plsrca.res$r2_y)*100,digits=2)`% of the variance in the genotypic data. With the adjusted data we can now perform our intended analyses. Although this analysis produced `r length(big.plsrca.res$d)` components (latent variables), we focus on just the first (`r round(big.plsrca.res$r2_y[1]*100,digits=2)`% of genotypic variance explained by AV45 brain data). 

```{r echo=F,results="asis",fig.height=8, out.width = ".8\\textwidth", results="asis", out.height=".8\\textheight", fig.align="center", fig.cap="\\label{fig:brain_genotypes_ex2} PLS-CA-R to predict genotypes from amyloid burden (\"AV45 uptake\"). The top figure (A) shows the latent variable scores for the observations on the first latent variable with group averages. The bottom figures (B) and (C) show the amyloid burden in cortical regions and the genotypes, respecively. In (A) we see a gradient from the Alzheimer's Disease (AD) group to the control (CON) group. Items above expected contribution to variance on the first LV are in purple.",fig.pos = "!hbtp"}
  par.opts <- par(no.readonly = T)

  big.fi.show <- which((big.plsrca.res$u[,1]^2) > (1/nrow(big.plsrca.res$fi)))
  big.fj.show <- which((big.plsrca.res$v[,1]^2) > (1/ncol(genetic.nom)))

  big.fi.cols <- rep(prettyGraphs::add.alpha("grey80",.6),nrow(big.plsrca.res$u))
    big.fi.cols[big.fi.show] <- "mediumorchid4"
  big.fj.cols <- rep(prettyGraphs::add.alpha("grey80",.6),nrow(big.plsrca.res$v))
    big.fj.cols[big.fj.show] <- "mediumorchid4"
  
    
  layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))
  
  sp.latentvar_plot(big.plsrca.res, display_names = F, bg=prettyGraphs::add.alpha(ind.cols[rownames(big.plsrca.res$lx)],.5),col=prettyGraphs::add.alpha("grey80",.5),pch=21)
  big.Lv1.grps <- t(W.DESIGN[rownames(big.plsrca.res$lx),]) %*% cbind(big.plsrca.res$lx[,1],big.plsrca.res$ly[,1])
  points(big.Lv1.grps,col=prettyGraphs::add.alpha("black",.6),pch=18,cex=3.35)
  points(big.Lv1.grps,col=grp.cols,pch=18,cex=3)
  legend("topleft",legend=c("CN","SMC","EMCI","LMCI","AD"),pch=18,col=grp.cols[c("CN","SMC","EMCI","LMCI","AD")],text.col = grp.cols[c("CN","SMC","EMCI","LMCI","AD")], cex=.75)
  mtext(paste0("(A)"), side = 3, adj = 0,line=0.75,cex=1.5)

  # ours::component_plot(big.plsrca.res$fi %*% diag(1/big.plsrca.res$d),cex=1,text.cex = .5,pch=20,display_names = F,col=big.fi.cols,main="Predictors\n(Regional AV45)")
  ours::component_plot(big.plsrca.res$fi,cex=1,text.cex = .5,pch=20,display_names = F,col=big.fi.cols,main="Predictors\n(Regional AV45)")
  thigmophobe.labels(big.plsrca.res$fi[big.fi.show,1], big.plsrca.res$fi[big.fi.show,2], labels=rownames(big.plsrca.res$fi)[big.fi.show],col="mediumorchid4",cex=.5)
  mtext(paste0("(B)"), side = 3, adj = 0,line=0.75,cex=1.5)
  
  # ours::component_plot(big.plsrca.res$fj %*% diag(1/big.plsrca.res$d),display_names = F,pch=20,cex=1, text.cex = .5, col=big.fj.cols, main="Responses\n(Genotypes)")
  ours::component_plot(big.plsrca.res$fj,display_names = F,pch=20,cex=1, text.cex = .5, col=big.fj.cols, main="Responses\n(Genotypes)")
  thigmophobe.labels(big.plsrca.res$fj[big.fj.show,1], big.plsrca.res$fj[big.fj.show,2], labels=rownames(big.plsrca.res$fj)[big.fj.show],col="mediumorchid4",cex=.5)
  mtext(paste0("(C)"), side = 3, adj = 0,line=0.75,cex=1.5)
  
  par(par.opts)
  
```


The first latent variable in Figure \ref{fig:brain_genotypes_ex2}a is associated with only the horizontal axes (Component 1) in Figure \ref{fig:brain_genotypes_ex2}b and c. The horizontal axis in Fig. \ref{fig:brain_genotypes_ex2}a is associated with the horizontal axis in Fig. \ref{fig:brain_genotypes_ex2}b whereas the vertical axis in Fig. \ref{fig:brain_genotypes_ex2}a is associated with the horizontal axis in Fig. \ref{fig:brain_genotypes_ex2}c. The first latent variable (Figure \ref{fig:brain_genotypes_ex2}a) shows a gradient: from left to right we see the groups configured from CN to AD. On the first latent variable we do also see a group-level dissociation where AD+LMCI are entirely on one side whereas EMCI+SMC+CN are on the opposite side for both ${\bf L}_{\bf X}$ (AV45 uptake, horizontal) and ${\bf L}_{\bf Y}$ (genotypes, vertical); effectively the means of AD and LMCI exist in the upper right quadrant and the means of the EMCI, SMC, and CN groups exist in the lower left quadrant. Higher relative AV45 uptake for the regions on the left side of Component 1 are more associated with EMCI, SMC, and CN than with the other groups, whereas higher relative AV45 uptake for the regions on the right side of Component 1 are more associated with AD and LMCI (Fig. \ref{fig:brain_genotypes_ex2}b). The genotypes on the left side are associated with the uptake in regions on the left side; likewise the genotypes on the right side are associated with the uptake in regions on the right side (Fig. \ref{fig:brain_genotypes_ex2}c). For example, LV/Component 1 shows relative uptake in right and left frontal pole, rostral middle frontal, and medial orbitofrontal regions are more associated with the following genotypes: AA and AG from rs769449, GG from rs2075650, GG from rs4420638, and AA from rs157582, than with other genotypes; these effects are generally driven by the AD and LMCI groups. Conversely, LV/Component 1 shows higher relative uptake in right and left lingual, cuneus, as well left parahippocampal and left entorhinal are more associated with the following genotypes: TT from rs405697, GG from rs6859, TC+TT from rs7412, TT from rs2830076, GG from rs157580, and AA from rs4420638 genotypes than with other genotypes; these effects are generally driven by the CN, SMC, and EMCI cohorts. In summary, the PLS-CA-R results show that particular patterns of regional AV45 uptake predict particular genotypic patterns across many SNPs, and that the sources these effects are generally driven by the groups. Furthermore the underlying brain and genotypic effects of the groups exist along a spectrum of severity.  


# Discussion
\label{section:Disc}

<!-- NO HOME: All of the PLS-CA-R analyses revealed particular patterns for control (CON, SMC) vs. disease groups (LMCI, AD).    -->

Many modern studies, like ADNI, measure individuals with a variety of scales such as: genetics and genomics, brain structure and function, many aspects of cognition and behavior, batteries of clinical measures, and so on. These data are complex, heterogeneous, and more frequently these data are "wide" (many more variables than subjects) instead of "big" (more subjects than variables). But many current strategies and approaches to handle such multivariate heterogeneous data often requires compromises or sacrifices (e.g., the presumption of single numeric model for categorical data such as the additive model for SNPs; z-scores of ordinal values; or "dichotomania" (https://www.fharrell.com/post/errmed/#catg): the binning of continuous values into categories). Many of these strategies and approaches presume data are interval scale. Because of the many features and flexibility of PLS-CA-R---e.g., best fit to predictors, orthogonal latent variables, accommodation for virtually any data type---we are able to identify distinct variables and levels (e.g., genotypes) that define or contribute to control (CON) vs. disease (AD) effects (e.g., Fig. \ref{fig:contributions_ex1}) or reveal particular patterns anchored by the polar control and disease effects (CON $\rightarrow$ SMC $\rightarrow$ EMCI $\rightarrow$ LMCI $\rightarrow$ AD; see, e.g., Fig. \ref{fig:brain_genotypes_ex2}).

<!--  As a generalization of PLS-R, PLS-CA-R [[Needed transition]]. Because PLS-CA-R is a generalization of PLS-R, many of the standard inferential and stability approaches still apply, [[explain inference here and how the stndard approaches can be used and refer to typical papers]]. --> 

While we focused on particular ways of coding and transforming data, there are many alternatives that could be used with PLS-CA-R. For example, we used a disjunctive approach for SNPs because they are categorical, which matches the genotypic model. However, through various disjunctive schemes, or other forms of Escofier or fuzzy coding, we could have used any genetic model: if all SNPs were coded as the major vs. the minor allele ('AA' vs. {'Aa+aa'}), this would be the dominant model, or we could have assumed the additive model ---i.e., 0, 1, 2 for 'AA', 'Aa', and 'aa', respectively---and transformed the data with the ordinal approach (but we strongly emphasize *not* the continuous approach). We previously provided a comprehensive guide on how to transform various SNP genetic models for use in PLS-CA and CA elsewhere [see Appendix of @beaton_partial_2016]. Furthermore, we only highlighted one of many possible methods to transform ordinal data. The term "fuzzy coding" applies more generally to the recoding of ordinal, ranked, preference, and even continuous data across a number of schemes, all of which conform to the same properties as disjunctive data. The many "fuzzy" and "double" coding schemes are generally found in @escofier_traitement_1979, @lebart_multivariate_1984, or @greenacrefuzzy. However, for ordinal data---especially with fewer than or equal to 10 levels, and without excessively rare ($\leq 1$%) occurences---we recommend to treat ordinal values as categorical levels. When ordinal data are treated as categorial (and disjunctively coded), greater detail about the levels emerges and in most cases reveal non-linear patterns of the ordinal levels.

We introduced PLS-CA-R in a way that emphasizes various recoding schemes to accomodate different data types. We designed PLS-CA-R as a mixed-data generalization of PLSR, which provides one strategy to identify latent variables and perform regression when standard assumptions are not met (e.g., HDLSS or high collinearity). PLS-CA-R---and GPLS---addresses the need of many fields that require \textit{data type general} methods across multi-source and multi-domain data sets where we require careful considerations about how we prepare and understand our data [@nguyen2019ten]. We introduced PLS-CA-R in a way that emphasizes various recoding schemes to accomodate different data types all with respect to CA and the $\chi^2$ model. PLS-CA-R provides key features necessary for data analyses as data-rich and data-heavy disciplines and fields rapidly move towards and depend on fundamental techniques in machine and statistical learning (e.g., PLSR, CCA). Finally, with techniques such as mixed-data MFA [@becue-bertaut_multiple_2008], PLS-CA-R provides a much needed basis for development of future methods designed for such complex data sets.


[SEE THE APPENDIX FOR A TON OF STUFF.]

# Acknowledgements

Data collection and sharing for this project was funded by the Alzheimer's Disease Neuroimaging Initiative
(ADNI) (National Institutes of Health Grant U01 AG024904) and DOD ADNI (Department of Defense award
number W81XWH-12-2-0012). ADNI is funded by the National Institute on Aging, the National Institute of
Biomedical Imaging and Bioengineering, and through generous contributions from the following: AbbVie,
Alzheimer‚Äôs Association; Alzheimer‚Äôs Drug Discovery Foundation; Araclon Biotech; BioClinica, Inc.; Biogen;
Bristol-Myers Squibb Company; CereSpir, Inc.; Cogstate; Eisai Inc.; Elan Pharmaceuticals, Inc.; Eli Lilly and
Company; EuroImmun; F. Hoffmann-La Roche Ltd and its affiliated company Genentech, Inc.; Fujirebio; GE
Healthcare; IXICO Ltd.; Janssen Alzheimer Immunotherapy Research & Development, LLC.; Johnson &
Johnson Pharmaceutical Research & Development LLC.; Lumosity; Lundbeck; Merck & Co., Inc.; Meso
Scale Diagnostics, LLC.; NeuroRx Research; Neurotrack Technologies; Novartis Pharmaceuticals
Corporation; Pfizer Inc.; Piramal Imaging; Servier; Takeda Pharmaceutical Company; and Transition
Therapeutics. The Canadian Institutes of Health Research is providing funds to support ADNI clinical sites
in Canada. Private sector contributions are facilitated by the Foundation for the National Institutes of Health
(www.fnih.org). The grantee organization is the Northern California Institute for Research and Education,
and the study is coordinated by the Alzheimer‚Äôs Therapeutic Research Institute at the University of Southern
California. ADNI data are disseminated by the Laboratory for Neuro Imaging at the University of Southern
California.



